<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>计算机组成与系统</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="本书将从 C 语言开始，逐步深入到底层汇编语言，一步步带你梳理计算机底层的逻辑。">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="preface.html">前言</a></li><li class="chapter-item expanded affix "><li class="part-title">开发环境 Linux & C</li><li class="chapter-item expanded "><a href="topic_0/linux_intro.html"><strong aria-hidden="true">1.</strong> Linux 介绍</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="topic_0/linux_on_windows.html"><strong aria-hidden="true">1.1.</strong> Windows 模拟 Linux 环境</a></li><li class="chapter-item expanded "><a href="topic_0/linux_virtual_box.html"><strong aria-hidden="true">1.2.</strong> Ubuntu 虚拟机安装及配置</a></li></ol></li><li class="chapter-item expanded "><a href="topic_0/linux_command.html"><strong aria-hidden="true">2.</strong> Linux 命令行</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="topic_0/linux_command_pt1.html"><strong aria-hidden="true">2.1.</strong> 基本命令</a></li><li class="chapter-item expanded "><a href="topic_0/linux_command_pt2.html"><strong aria-hidden="true">2.2.</strong> 文件操作</a></li><li class="chapter-item expanded "><a href="topic_0/linux_command_pt3.html"><strong aria-hidden="true">2.3.</strong> 文件搜索</a></li></ol></li><li class="chapter-item expanded "><a href="topic_0/from_cxx_to_c.html"><strong aria-hidden="true">3.</strong> 从 C++ 到 C</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="topic_0/from_cxx_to_c_simpio.html"><strong aria-hidden="true">3.1.</strong> simpio.h</a></li><li class="chapter-item expanded "><a href="topic_0/from_cxx_to_c_strlib.html"><strong aria-hidden="true">3.2.</strong> strlib.h</a></li><li class="chapter-item expanded "><a href="topic_0/from_cxx_to_c_pig_latin.html"><strong aria-hidden="true">3.3.</strong> Pig Latin</a></li></ol></li><li class="chapter-item expanded "><a href="topic_0/lab_0.html"><strong aria-hidden="true">4.</strong> 实验 0：使用课程服务器</a></li><li class="chapter-item expanded "><a href="topic_0/assign_0.html"><strong aria-hidden="true">5.</strong> 作业 0：上手 Linux 和 C</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="topic_0/assign_0_pt1.html"><strong aria-hidden="true">5.1.</strong> 入侵者检测</a></li><li class="chapter-item expanded "><a href="topic_0/assign_0_pt2.html"><strong aria-hidden="true">5.2.</strong> 谢尔宾斯基分形</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">数据的表示 Data Representation</li><li class="chapter-item expanded affix "><li class="part-title">数组和指针 Array & Pointer</li><li class="chapter-item expanded affix "><li class="part-title">栈和堆 Stack & Heap</li><li class="chapter-item expanded affix "><li class="part-title">泛型编程 Generic C</li><li class="chapter-item expanded affix "><li class="part-title">汇编语言 x86-64 Assembly</li><li class="chapter-item expanded affix "><li class="part-title">堆分配器 Heap Allocator</li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="misc/contributors.html">更新记录</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">计算机组成与系统</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<p>计算机科学教学的前两年，重点是训练你的编程方法和抽象思维能力。在斯坦福大学成功的教学经验中，这两个任务分别由 CS106A 和 CS106B 两门课完成。在 StickMind 课程规划中，这两个任务由 CS101 课程完成，选用 C++ 编程语言。未来也可能会推出现代 C 语言版本的 CS101，敬请期待。</p>
<p>编程方法学的重点是将程序<strong>写对</strong>，能够利用逐步求精等基本策略，将稍大一些的程序进行分解。这类课程一般会设置一些小游戏或者文本处理，只要求程序能够正确运行即可。抽象思维的重点则是将程序<strong>写好</strong>，利用一些经典的数据结构和算法，你可以解决一些更为复杂的问题。这类课程不仅要求你把程序写对，更要求你能够高效地解决问题。</p>
<p>经过这些前置课程的训练，你基本能够掌握以下一些能力：</p>
<ul>
<li>了解 Python/C++/Java 基本语法</li>
<li>会用递归思维解决问题</li>
<li>理解数据抽象并能够实现经典的抽象数据类型（链表、栈、堆、集合、映射）</li>
<li>理解并能够实现经典算法（搜索、排序、回溯、哈希）</li>
</ul>
<p>作为一名程序员，你也应该具备良好的软件工程能力，能够编写组织良好、可读性强的代码。</p>
<p>本课程在计算机科学教学中充当了承上启下的作用。这类课程一般以“计算机组成原理”或“计算机系统基础”冠名。前者偏重硬件，会涉及到 CPU 的内部细节，甚至会要求你设计一个 CPU 模拟器；而后者则偏重软件，以软件开发者的视角抽象看待硬件，不会在硬件层面花费太多精力。本课程倾向于后者，继续提升你的编程技术，在广度和深度上拓展你的编程经验。</p>
<p>本课程将从 C 语言开始，逐步深入到底层汇编语言，一步步带你梳理计算机的运行机制。当完全理解计算机如何执行程序并操作数据时，你将会成为一名更高效的程序员，特别是在处理调试问题、性能优化、内存管理以及程序健壮性方面。只有理解程序是如何运行的，你才能更好地理解 Python/C++/Java 这些高级语言的底层执行逻辑，才能更快地学习其他编程语言进行开发。</p>
<p>本文档是《<a href="https://cs102.stickmind.com/">CS102：计算机组成与系统</a>》课程伴侣，章节规划大致和课程计划同步。大部分内容取材自《深入理解计算机系统》和《C 程序设计语言》两本教材，如有雷同，纯属故意。技术类书籍在没有掌握的情况下阅读，往往效率低下。通过课程、讲义或手册的形式，将一些核心的概念打磨清楚后再去看书，不仅可以节省大量宝贵的时间，还能真正领会字里行间的深意。所以，本书也可以作为上述两本教材的上手指南。</p>
<h2 id="目标"><a class="header" href="#目标">目标</a></h2>
<p>本课程的目标是让学生<strong>掌握</strong></p>
<ul>
<li>以复杂的内存和指针方式编写 C 程序</li>
<li>对地址空间以及 C 程序的编译/运行时行为，能够建立一个准确的模型</li>
</ul>
<p>获得以下<strong>能力</strong></p>
<ul>
<li>把 C 语言转换到 x86-64 汇编语言</li>
<li>编写适配硬件算术局限性的程序</li>
<li>识别程序瓶颈并提高运行时性能</li>
<li>在 Linux 环境中开发程序</li>
</ul>
<p>贯穿整个课程，最终会带你揭开计算机基础架构的奥秘。</p>
<h2 id="试听"><a class="header" href="#试听">试听</a></h2>
<p><a href="https://www.cctalk.com/m/group/90917111">CS102：计算机组成与系统（试听版）</a>包含前 4 个话题的录播剪辑。试听版仅提供录播内容，不提供任何答疑、作业、批改等服务。试听平台限制课程人数为 500 人，象征性收取 1 元，保留更多名额给有需要的同学。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-介绍"><a class="header" href="#linux-介绍">Linux 介绍</a></h1>
<blockquote>
<p><strong>本节参考录播</strong>：</p>
<p><strong>开发环境 Linux &amp; C</strong>/</p>
<ol>
<li>Windows 模拟 Linux 环境-V230911.mp4</li>
<li>Ubuntu 虚拟机安装及配置-V230912.mp4</li>
</ol>
</blockquote>
<p>本章通过一些基本概念介绍 Linux 的开发环境。首先，我们会讨论 Linux 基金会；然后，介绍一些流行的 Linux 发行版。最终目的是希望大家能够选择一款合适的发行版，作为日常开发的必备工具。</p>
<h2 id="linux-历史"><a class="header" href="#linux-历史">Linux 历史</a></h2>
<p>Linux 是一种开源计算机操作系统，最初是在基于英特尔 x86 的个人计算机上开发的。随后，它被移植到了一系列其他硬件平台上，从小型嵌入式设备到世界上最大的超级计算机。</p>
<p>1991 年，Linus Torvalds 还是芬兰赫尔辛基的一名学生。当时他开始了一个项目：编写自己的操作系统<strong>内核</strong>。他还收集并开发了以内核为中心的整个操作系统所需的其他基本组件。没过多久，该项目就被命名为 Linux 内核，并最终发展成为对当今世界产生巨大影响的项目。</p>
<p>1992 年，Linux 通过 <strong>GNU</strong>（自由软件基金会 FSF 的一个项目，推广免费软件）使用 <strong>GPL</strong> 许可，这使它能够建立一个全球开发者社区。通过将内核与 GNU 项目中的其他系统组件相结合，许多其他开发人员创建了名为 <strong>Linux 分发版</strong>的完整系统，该系统首次出现在 90 年代中期。</p>
<p>90 年代中期创建的 Linux 发行版完全免费，为计算提供了基础，并成为开源软件运动的推动力。1998 年，IBM 和 Oracle 等大公司宣布支持 Linux 平台，并开始了一系列重大的开发工作。</p>
<h2 id="linux-基金会"><a class="header" href="#linux-基金会">Linux 基金会</a></h2>
<p>Linux 基金会（LF）是一个非营利性技术联盟，负责托管和促进开源软件项目的协作开发。除了提供一个可以保护和加速 Linux 内核开发的中立组织之外，LF 还致力于围绕开源项目构建一个可持续的生态系统，以加速技术开发和商业应用。</p>
<p>Linux 基金会项目对世界基础设施至关重要，包括 Linux、Kubernetes、Node.js、ONAP、PyTorch、RISC-V、SPDX、OpenChain 等。Linux 基金会专注于利用最佳实践，满足贡献者、用户和解决方案提供商的需求，为开放协作创建可持续的模型。</p>
<p><em>参见：<a href="https://www.linuxfoundation.org/">linuxfoundation.org</a></em></p>
<h2 id="三大主流-linux-发行版家族"><a class="header" href="#三大主流-linux-发行版家族">三大主流 Linux 发行版家族</a></h2>
<p>最具代表性的几个发行版家族有：</p>
<ul>
<li>Red Hat 系统家族（包含 CentOS 和 Fedora）</li>
<li>SUSE 系统家族（包含 openSUSE）</li>
<li>Debian 系统家族（包含 Ubuntu 和 Linux Mint）</li>
</ul>
<p><img src="topic_0/./assets/linux-kernel-distribution-families.png" alt="linux distribution" /></p>
<p><em>参见：<a href="https://lwn.net/Distributions/">The LWN.net Linux Distribution List</a></em></p>
<p>Linux 基金会发布的软件都会保持发行版兼容性，这意味着这些软件几乎可以在所有的现代发行版中无差别运行。不同发行版之间可能仅仅是包管理器、软件版本、文件位置之间有些许差异。掌握任何一个发行版的使用后，都可以很快地迁移到另一个。</p>
<h2 id="red-hat-系统家族"><a class="header" href="#red-hat-系统家族">Red Hat 系统家族</a></h2>
<p>Red Hat Enterprise Linux（RHEL）家族包括 Fedora，Rocky Linux 和 Oracle Linux 在内的系列产品。</p>
<p>Fedora 与 RHEL 有着密切的关系，并且包含的软件比 Red Hat 的企业版多得多。其中一个原因是，一个多元化的社区参与了 Fedora 的构建，其中许多贡献者并不为 Red Hat 工作。此外，它还被用作未来 RHEL 版本的测试平台。</p>
<p>由于 CentOS 8 在 2021 年之后不再更新，Rocky Linux 挑起了大梁，目的是提供一个由社区驱动的企业版 RHEL。</p>
<p>关于 Red Hat 家族的一些信息：</p>
<ul>
<li>Fedora 是 RHEL 的上游测试平台</li>
<li>Rocky Linux 是 RHEL 的克隆</li>
<li>支持多个硬件平台</li>
<li>使用基于 RPM 的 dnf 包管理器来安装、更新和删除系统中的包</li>
<li>RHEL 在企业中有着广泛的使用。</li>
</ul>
<h2 id="suse-系统家族"><a class="header" href="#suse-系统家族">SUSE 系统家族</a></h2>
<p>SUSE Linux Enterprise Server (SLES)/openSUSE 的关系和 RHTL/Fedora 很相似。</p>
<p>关于 SUSE 家族的一些信息：</p>
<ul>
<li>SLES 是 openSUSE 的上游</li>
<li>使用基于 RPM 的 zypper 包管理器来安装、更新和删除包</li>
<li>包括用于系统管理目的的 YaST 应用程序。</li>
<li>SLES 广泛应用于零售业等其他行业</li>
</ul>
<h2 id="debian-系统家族"><a class="header" href="#debian-系统家族">Debian 系统家族</a></h2>
<p>Debian 发行版是 Ubuntu 和 Linux Mint 等其他几个发行版的上游，通常用于服务器和台式计算机。Debian 是一个纯粹的开源社区项目（不属于任何公司），并且非常注重稳定性。</p>
<p>Debian 为所有 Linux 发行版的用户提供了迄今为止最大、最完整的软件仓库。Ubuntu 旨在提供长期稳定性和易用性之间的良好折衷。由于 Ubuntu 的大部分软件包都来自 Debian 的稳定分支，继承了 Debian 的超大软件仓库。本课程将基于 Ubuntu 22.04 LTS 发行版进行学习。</p>
<p>关于 Debian 家族的一些信息：</p>
<ul>
<li>Debian 家族是 Ubuntu 的上游，Ubuntu 是 Linux Mint 和其他版本的上游</li>
<li>使用基于 DPKG 的 APT 包管理器来安装、更新和删除包</li>
<li>Ubuntu 已被广泛用于云部署</li>
<li>虽然 Ubuntu 是在 Debian 之上构建的，并且是基于 GNOME 的，但它在视觉上与标准 Debian 以及其他发行版上的界面不同</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-模拟-linux-环境"><a class="header" href="#windows-模拟-linux-环境">Windows 模拟 Linux 环境</a></h1>
<h2 id="本节目标"><a class="header" href="#本节目标">本节目标</a></h2>
<p>由于大部分同学使用 Windows 系统，在 Windows 平台体验 Linux 开发工具也是可以的。完成本节内容的学习，你应该能够尝试解决以下问题：</p>
<ul>
<li>什么是 MSYS2？如何安装 MSYS2？</li>
<li>如何使用 <code>pacman</code> 包管理工具更新、安装、删除软件包？</li>
<li>如何修改 MSYS2 国内源？</li>
<li>如何使用 MSYS2 编译/运行 C 程序？</li>
</ul>
<h2 id="安装-msys2-开发工具"><a class="header" href="#安装-msys2-开发工具">安装 MSYS2 开发工具</a></h2>
<p><a href="https://www.msys2.org/">MSYS2</a> 提供了一个易于使用的类 Linux 环境来构建、安装和运行本机 Windows 软件。配合 VS Code 等开发工具，可以搭建一个较为轻量的开发环境。对于一些 POSIX 依赖不太严格的测试，比起使用 Linux 虚拟机更为直接、方便。</p>
<p>安装过程，有以下几点需要注意：</p>
<ul>
<li>国内用户建议<strong>断网安装</strong>，避免中途出现更新密钥卡死的问题</li>
<li>安装完后，国内用户建议<strong>修改国内软件源</strong>，提高下载速度</li>
<li>后续软件体积较大，建议安装在非 C 盘根目录</li>
<li>建议使用 MSYS2 UCRT 子系统，和课程保持一致</li>
<li>优先安装 <code>mingw-w64-ucrt-x86_64-</code> 前缀的软件包</li>
</ul>
<p>常用命令总结如下，方便后续使用查询，参考连接：<a href="https://www.msys2.org/docs/package-management/">Package Management</a></p>
<ul>
<li>
<p>更新 MSYS2 组件，修改源后建议更新两次</p>
<pre><code>pacman -Suy
</code></pre>
</li>
<li>
<p>安装 <code>openssh</code> 可用于后续连接远程服务器</p>
<pre><code>pacman -S openssh
</code></pre>
</li>
<li>
<p>安装 <code>gcc</code>、<code>gdb</code>、<code>pkg-config</code> 等常用开发工具</p>
<pre><code>pacman -S mingw-w64-ucrt-x86_64-toolchain
</code></pre>
</li>
<li>
<p>安装 <code>make</code>，<code>cmake</code>，<code>ninja</code> 等构建工具</p>
<pre><code>pacman -S make mingw-w64-ucrt-x86_64-cmake mingw-w64-ucrt-x86_64-ninja
</code></pre>
</li>
</ul>
<h2 id="编译运行-c-程序"><a class="header" href="#编译运行-c-程序">编译运行 C 程序</a></h2>
<p>在 MSYS2 当前目录创建一个 <code>hello.c</code> 文件，输入以下代码：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
	printf(&quot;Hello World.\n&quot;);
	return 0;
}
</code></pre>
<p>使用以下命令编译你的第一个 C 程序：</p>
<pre><code>gcc hello.c -o hello
</code></pre>
<p>运行该程序，需要以 <code>./</code> 开头执行以下命令：</p>
<pre><code>./hello
</code></pre>
<p>前缀 <code>./</code> 表示在当前目录下寻找 <code>hello</code> 程序。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ubuntu-虚拟机安装及配置"><a class="header" href="#ubuntu-虚拟机安装及配置">Ubuntu 虚拟机安装及配置</a></h1>
<h2 id="本节目标-1"><a class="header" href="#本节目标-1">本节目标</a></h2>
<p>本节带大家使用 VirtualBox 安装一个 Ubuntu 22.04 LTS 桌面系统，并尝试使用 OpenSSH 模拟远程登陆。完成本节内容的学习，你应该能够尝试解决以下问题：</p>
<ul>
<li>如何通过 VirtualBox 安装 Ubuntu 虚拟机？</li>
<li>如何使用 <code>apt</code> 包管理器安装、更新、删除软件包？</li>
<li>如何修改 Ubuntu 软件源提高下载速度？</li>
<li>如何使用 MSYS2 的 <code>ssh</code> 工具访问 Ubuntu 虚拟机？</li>
</ul>
<h2 id="安装-ubuntu-虚拟机"><a class="header" href="#安装-ubuntu-虚拟机">安装 Ubuntu 虚拟机</a></h2>
<p><a href="https://www.virtualbox.org/">VirtualBox​​</a> 是 Oracle 提供的一款流行的虚拟化软件，可用于 Linux、mac 和 Windows 系统。由于 Linux 系统相对灵活，软件包依赖维护较差，在不熟悉的情况下，很容易造成系统破坏，无法开机等问题。所以，初学阶段没必要在物理机上安装真实的 Linux 系统，就目前的学习而言，虚拟机提供的功能完全够用。一旦虚拟机出现问题，可以直接删除，重新安装。</p>
<p>提前下载 VirtualBox 和 Ubuntu 22.04 LTS 镜像：</p>
<ul>
<li><a href="https://download.virtualbox.org/virtualbox/7.0.10/VirtualBox-7.0.10-158379-Win.exe">点击下载 VirtualBox</a></li>
<li><a href="https://mirrors.aliyun.com/ubuntu-releases/22.04/ubuntu-22.04.3-desktop-amd64.iso">点击下载 Ubuntu 22.04 LTS</a></li>
</ul>
<p>详细的安装过程，请跟随课堂视频一步步完成安装。</p>
<h2 id="安装开发工具"><a class="header" href="#安装开发工具">安装开发工具</a></h2>
<p><code>apt</code> 命令是一个功能强大的命令行工具，它与 Ubuntu 的高级打包工具（APT）配合使用。 <code>apt</code> 中包含的命令提供了安装新软件包、升级现有软件包、更新软件包列表索引、甚至升级整个 Ubuntu 系统的方法。</p>
<p>尝试安装以下软件：</p>
<ul>
<li>
<p><code>build-essential</code> 包含了常用的 <code>gcc</code> 开发工具</p>
<pre><code>sudo apt install build-essential
</code></pre>
</li>
<li>
<p>安装 <code>gdb</code>、<code>valgrind</code> 调试器和内存检测工具</p>
<pre><code>sudo apt install gdb valgrind
</code></pre>
</li>
<li>
<p>安装 <code>git</code>，<code>cmake</code> 等常用工具</p>
<pre><code>sudo apt install git cmake ninja-build
</code></pre>
</li>
</ul>
<p><strong><em>参考文献</em></strong>：</p>
<ul>
<li><a href="https://ubuntu.com/server/docs/package-management">Package management</a></li>
</ul>
<h2 id="安装-ssh-工具"><a class="header" href="#安装-ssh-工具">安装 SSH 工具</a></h2>
<p>OpenSSH 是一个功能强大的工具集，用于远程控制联网计算机以及在联网计算机之间传输数据。OpenSSH 客户端和服务器应用程序的安装非常简单。</p>
<p>使用以下命令在 Ubuntu 系统上安装 OpenSSH 客户端应用程序：</p>
<pre><code>sudo apt install openssh-client
</code></pre>
<p>使用以下命令在 Ubuntu 系统上安装 OpenSSH 服务器应用程序：</p>
<pre><code>sudo apt install openssh-server
</code></pre>
<p>默认情况下，OpenSSH 服务将会自动启动，也可以使用下述命令手动开启服务：</p>
<pre><code>sudo systemctl start sshd.service
</code></pre>
<p><strong><em>参考文献</em></strong>：</p>
<ul>
<li><a href="https://ubuntu.com/server/docs/service-openssh">OpenSSH Server</a></li>
</ul>
<h2 id="模拟远程登陆"><a class="header" href="#模拟远程登陆">模拟远程登陆</a></h2>
<p>这里需要先配置端口转发，详细的配置过程，请跟随课堂视频一步步完成。</p>
<p><img src="topic_0/./assets/port-forwarding.png" alt="port forwarding" /></p>
<p>完成端口转发配置后，我们可以使用终端模拟远程登陆：</p>
<pre><code>$ ssh cs@localhost -p 2222
The authenticity of host '[localhost]:2222 ([127.0.0.1]:2222)' can't be established.
ED25519 key fingerprint is SHA256:gfHLfANKNM4cCAoDEZ/CiZ97ql3lfUA2CVM28H6JssM.
This key is not known by any other names.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[localhost]:2222' (ED25519) to the list of known hosts.
cs@localhost's password:
Welcome to Ubuntu 22.04.3 LTS (GNU/Linux 6.2.0-26-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

Last login: Tue Aug 15 13:56:00 2023 from 10.0.2.2
</code></pre>
<h2 id="vs-code-官方远程插件工作流"><a class="header" href="#vs-code-官方远程插件工作流">VS Code 官方远程插件工作流</a></h2>
<p>前往官网下载安装 <a href="https://code.visualstudio.com/">VS Code</a>，在插件市场搜索并安装 <strong>Remote - SSH</strong> 插件。</p>
<p><img src="topic_0/./assets/remote-ssh.png" alt="Remote - SSH" /></p>
<p>插件安装完成后，在工具栏选择 Remote Explorer 模块，点击 SSH 后面的 <strong><code>+</code></strong> 号。在弹出的输入窗口中，输入 SSH 登陆地址。</p>
<pre><code>ssh cs@localhost -p 2222
</code></pre>
<p>随后会提示选择配置文件保存位置，此处直接“回车”选择默认位置即可。</p>
<p><img src="topic_0/./assets/remote-ssh-connect.png" alt="Remote - SSH Connect" /></p>
<p>此时点击 Remote 右侧的刷新按钮，就可以看到服务器 IP。连接该服务器，只需要点击 IP 右侧的箭头，随后输入你的账户密码就可以登录。登录成功后，可以在 VS Code 右下角看到连接状态。</p>
<p><img src="topic_0/./assets/remote-ssh-ok.png" alt="Remote - SSH OK" /></p>
<p>服务器连接成功后，通过 VS Code 菜单栏 <strong>File</strong> 可以选择 “<strong>Open File/Open Folder</strong>” 编辑你的文件或项目。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-命令行"><a class="header" href="#linux-命令行">Linux 命令行</a></h1>
<p>Linux 发行版通常提供多种不同的图形桌面环境，极大地方便了不同用户的使用习惯，但是 Linux 系统真正强大的却是命令行。本课程建议大家选择一款流行的桌面环境，将更多的精力放在命令行的学习上，而不是放在五花八门的桌面环境定制上。</p>
<p>从今天开始，通过命令行工具和你的 Linux 系统进行交互，并一直走下去。真正的 Linux 系统管理员也是花费了大量的时间在命令行的工具上，通过文本界面自动化一些任务，解决一些问题。有句话是这么说的，“图形用户界面让简单的事情变得更简单，而命令行界面让困难的任务变得可能”。Linux 系统严重依赖大量的命令行工具，这些工具有以下一些优点：</p>
<ul>
<li>没有 GUI 开销，对硬件要求更友好</li>
<li>几乎所有的任务都能够通过命令行完成</li>
<li>可以为一些常见的任务定制命令脚本自动完成</li>
<li>可以在任何地方通过网络连接远程 Linux 服务器</li>
<li>图形界面在不同的发行版中会有差异，但命令行的使用却是通用的</li>
</ul>
<h2 id="使用文本终端"><a class="header" href="#使用文本终端">使用文本终端</a></h2>
<p>终端模拟器程序在桌面窗口中模拟独立终端，本质上就像你在没有运行图形界面的纯文本终端上登录机器一样。大多数终端模拟器程序支持打开多个终端会话。Ubuntu 默认使用 <code>gnome-terminal</code> 终端应用程序。</p>
<p><img src="topic_0/./assets/terminal.png" alt="terminal" /></p>
<h2 id="sudo"><a class="header" href="#sudo">sudo</a></h2>
<p><code>sudo</code> 为用户提供管理（admin）权限，允许用户使用 <code>root</code> 用户的安全权限来运行程序。全新安装的 Ubuntu 系统默认 <code>root</code> 密码是随机的，每次开机都会有一个新的密码。</p>
<p>如果想把该密码固定，可以打开终端，输入以下命令。重复输入两次密码进行设置（输入过程中，字符不会显示）。</p>
<pre><code>sudo passwd
</code></pre>
<p>此时我们可以通过以下命令切换到 <code>root</code> 用户。注意，在 <code>root</code> 用户下所有操作都是允许的，切记不要误改文件，否则无法恢复。</p>
<pre><code>su root
</code></pre>
<pre><code>cs@stickmind:~$ su root
Password: 
root@stickmind:/home/cs# 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基本命令"><a class="header" href="#基本命令">基本命令</a></h1>
<p>本节讨论如何通过命令行完成一些基本操作。</p>
<h2 id="登陆退出系统"><a class="header" href="#登陆退出系统">登陆/退出系统</a></h2>
<p>回顾虚拟机的使用教程，通过命令行，可以使用以下命令登陆系统。SSH 通过服务器地址 <code>172.0.0.1</code> 和端口 <code>2222</code> 访问系统中的 <code>cs</code> 账户：</p>
<pre><code>ssh cs@172.0.0.1 -p 2222
</code></pre>
<p>退出系统可以使用：</p>
<pre><code>exit
</code></pre>
<h2 id="重启关机"><a class="header" href="#重启关机">重启/关机</a></h2>
<p>使用 <code>shutdown</code> 命令可以关闭 Linux 系统。以下命令表示立刻关闭计算机（不加参数 <code>now</code>，则系统将会在 1 分钟后关机）：</p>
<pre><code>sudo shutdown now
</code></pre>
<p>重启计算机可以使用 <code>reboot</code> 命令。以下命令表示立刻重启计算机：</p>
<pre><code>sudo reboot
</code></pre>
<p><code>reboot</code> 命令等价于 <code>sudo shutdown -r now</code>。其中，参数 <code>now</code> 可以替换成具体时间，比如 <code>sudo shutdown -r +30</code> 表示 30 分钟后重启。</p>
<h2 id="访问路径"><a class="header" href="#访问路径">访问路径</a></h2>
<p>登陆系统后，默认的位置是个人账户目录，也可以通过系统变量 <code>$HOME</code> 查看：</p>
<pre><code>echo $HOME
</code></pre>
<p>在 Linux 系统中，该路径也可以使用 <code>~</code> 表示，例如 <code>~/Desktop</code> 表示 <code>/home/cs/Desktop</code>。</p>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody>
<tr><td><code>pwd</code></td><td>显示当前路径</td></tr>
<tr><td><code>cd ~</code> 或 <code>cd</code></td><td>切换到个人账户目录</td></tr>
<tr><td><code>cd ..</code></td><td>切换到上级目录 (<strong><code>..</code></strong>)</td></tr>
<tr><td><code>cd -</code></td><td>切换到前一步目录 <strong><code>-</code></strong> (减号)</td></tr>
</tbody></table>
</div>
<h2 id="定位程序位置"><a class="header" href="#定位程序位置">定位程序位置</a></h2>
<p>当我们执行命令时，系统会根据配置好的路径依次在目录中寻找该命令；如果找不到，则会提示 “not found”。可以通过系统变量 <code>PATH</code> 查看修改查找的路径和顺序。</p>
<pre><code>echo $PATH
</code></pre>
<p>根据输出可以看出，路径之间用冒号分隔，查询顺序从左到右依次进行。</p>
<pre><code>$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
</code></pre>
<p>在执行 <code>hello</code> 程序时，如果不添加 <code>./</code> 前缀，则系统会提示找不到 <code>hello</code> 命令，其原因就是 <code>PATH</code> 并不包含当前目录。如果我们将 <code>hello</code> 程序放到 <code>~/.local/bin</code> 目录下，则可以通过以下命令，将该路径添加到 <code>PATH</code> 变量中。</p>
<pre><code>export PATH=$HOME/.local/bin:$PATH
</code></pre>
<p>使用 <code>which</code> 命令可以定位程序的位置，该命令会在系统路径中查找程序的位置并输出，例如</p>
<pre><code>$ which make
/usr/bin/make
</code></pre>
<p>如果不局限系统路径，可以使用 <code>whereis</code> 命令扩大搜索范围。</p>
<pre><code>$ whereis diff
diff: /usr/bin/diff /usr/share/man/man1/diff.1.gz
</code></pre>
<h2 id="绝对路径-vs-相对路径"><a class="header" href="#绝对路径-vs-相对路径">绝对路径 vs 相对路径</a></h2>
<p>在 Linux 中定义路径的两种方式：</p>
<ul>
<li>
<p><strong>绝对路径</strong></p>
<p>绝对路径以根路径 <code>/</code> 开头，依次跟随目录树分支，定位到需要的位置，例如，<code>/usr/bin</code>。</p>
</li>
<li>
<p><strong>相对路径</strong></p>
<p>相对路径以当前路径开头，<code>.</code> 表示当前目录，<code>..</code> 表示上一级目录，<code>~</code> 表示个人账户目录。</p>
</li>
</ul>
<p>在个人账户目录中，执行以下命令都会切换到 <code>/usr/bin</code> 目录，</p>
<pre><code>$ pwd
/home/cs
$ cd /usr/bin
</code></pre>
<pre><code>$ pwd
/home/cs
$ cd ../../usr/bin
</code></pre>
<h2 id="查看文件系统"><a class="header" href="#查看文件系统">查看文件系统</a></h2>
<p>使用第三方工具 <code>tree</code> 可以很方便地浏览文件系统内容，通过以下命令进行安装：</p>
<pre><code>sudo apt install tree
</code></pre>
<p>直接使用 <code>tree</code> 命令会递归列出当前路径下所有文件树，通过 <code>-L</code> 指定层级可以指定显示的文件深度：</p>
<pre><code>$ tree -L 1
.
├── Desktop
├── Documents
├── Downloads
├── Music
├── Pictures
├── Public
├── snap
├── Templates
└── Videos
</code></pre>
<p>其他一些常用命令也可以实现类似目的：</p>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody>
<tr><td><strong><code>ls</code></strong></td><td>列出当前目录内容</td></tr>
<tr><td><strong><code>ls –a</code></strong></td><td>列出当前目录内容，包含 <code>.</code> 开头的隐藏文件</td></tr>
<tr><td><strong><code>ls -l</code></strong></td><td>以列表形式列出当前目录内容</td></tr>
</tbody></table>
</div>
<h2 id="练习"><a class="header" href="#练习">练习</a></h2>
<ol>
<li>使用 <code>whereis</code> 命令定位 <code>gcc</code> 程序的位置</li>
<li>显示当前路径</li>
<li>切换到 <code>/usr/bin</code> 目录</li>
<li>切换到个人账户目录</li>
<li>切换到上一级目录</li>
<li>使用 <code>-</code> 参数切换到前一步目录</li>
<li>显示当前路径</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文件操作"><a class="header" href="#文件操作">文件操作</a></h1>
<p>Linux 提供了许多命令用于查看文件的内容、创建新文件或空文件、更改文件的时间戳以及移动、删除和重命名文件或目录。这些命令可以用于管理数据和文件，并确保在正确的位置提供正确的数据。在本节中，我们将学习如何管理文件。</p>
<h2 id="查看文件"><a class="header" href="#查看文件">查看文件</a></h2>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody>
<tr><td><strong><code>cat</code></strong></td><td>用于查看不太长的文件，不提供页面操作</td></tr>
<tr><td><strong><code>tac</code></strong></td><td>逆序打印文件内容</td></tr>
<tr><td><strong><code>less</code></strong></td><td>用于查看较大的文件，提供页面操作，操作逻辑类似 <code>vi</code> 编辑器</td></tr>
<tr><td><strong><code>tail</code></strong></td><td>默认打印文件后 10 行内容，通过参数 <strong><code>-n 15</code></strong> 或 <strong><code>-15</code></strong> 可以改变显示的行数</td></tr>
<tr><td><strong><code>head</code></strong></td><td>和 <strong><code>tail</code></strong> 命令相反，默认打印文件前 10 行内容</td></tr>
</tbody></table>
</div>
<p><em><strong>补充</strong>：<code>vi</code> 编辑器使用 <strong><code>j</code></strong> 向下滚动，<strong><code>k</code></strong> 向上滚动，使用 <strong><code>/</code></strong> 向后查找，使用 <strong><code>?</code></strong> 向前查找。</em></p>
<h2 id="文件的创建"><a class="header" href="#文件的创建">文件的创建</a></h2>
<p><code>touch</code> 命令常用于更新文件的状态，默认修改文件时间戳为当前时间。不过，我们也可以使用该命令创建一个空白文件：</p>
<pre><code>touch myfile
</code></pre>
<p>更多功能可以查询帮助，比如使用 <code>-t</code> 可以设定具体的时间戳。以下命令将文件时间设置为 8 月 12 日 14 点整：</p>
<pre><code>touch -t 08121400 myfile
</code></pre>
<p><img src="topic_0/./assets/touch.png" alt="touch" /></p>
<h2 id="文件移动重命名等"><a class="header" href="#文件移动重命名等">文件移动、重命名等</a></h2>
<p><code>mv</code> 命令可以实现两个功能：</p>
<ul>
<li>重命名文件或文件夹</li>
<li>移动文件到另一个目录</li>
</ul>
<p>如果不确定删除哪些文件，可以是用 <code>-i</code> 交互操作。</p>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody>
<tr><td><strong><code>mv</code></strong></td><td>重命名文件</td></tr>
<tr><td><strong><code>rm</code></strong></td><td>删除文件</td></tr>
<tr><td><strong><code>rm –f</code></strong></td><td>强制删除文件</td></tr>
<tr><td><strong><code>rm –i</code></strong></td><td>交互删除文件</td></tr>
</tbody></table>
</div>
<h2 id="文件夹创建和删除"><a class="header" href="#文件夹创建和删除">文件夹创建和删除</a></h2>
<p><code>mkdir</code> 命令用于创建目录文件夹，例如，在当前目录创建文件夹可以使用</p>
<pre><code>mkdir myfolder
</code></pre>
<p>在指定目录创建文件夹可以使用</p>
<pre><code>mkdir ~/Desktop/myfolder
</code></pre>
<p>删除文件夹可以使用 <code>rmdir</code> 命令，默认只能删除空文件夹。使用命令 <code>rm -rf</code> 可以快速简单地递归删除整个文件夹。</p>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody>
<tr><td><strong><code>mv</code></strong></td><td>重命名文件夹</td></tr>
<tr><td><strong><code>rmdir</code></strong></td><td>删除空白文件夹</td></tr>
<tr><td><strong><code>rm -rf</code></strong></td><td>强制删除文件夹</td></tr>
</tbody></table>
</div>
<h2 id="修改命令行提示符"><a class="header" href="#修改命令行提示符">修改命令行提示符</a></h2>
<p>命令行工具通过变量 <code>PS1</code> 存储命令行的文本字符串，一般 Linux 发行版会默认设置一个值，例如：</p>
<pre><code>cs@stickmind:~$ 
</code></pre>
<p>通过修改该变量，可以定制显示的内容：</p>
<pre><code>PS1=&quot;cs102@virtualbox: &quot;
</code></pre>
<p>命令提示符将修改为：</p>
<pre><code>cs102@virtualbox: 
</code></pre>
<p><strong>注意</strong>，在终端直接赋值变量名，仅在当前激活的终端有效。重新打开终端，变量内容仍然是默认值。如果我们想永久修改该变量，可以尝试在 <code>.bashrc</code> 中进行设置。</p>
<h2 id="练习-1"><a class="header" href="#练习-1">练习</a></h2>
<ol>
<li>使用 <code>touch</code> 创建两个文件 <code>file1</code> 和 <code>file2</code></li>
<li>使用 <code>ls -l</code> 检查文件状态</li>
<li>将 <code>file1</code> 重命名为 <code>new_file1</code></li>
<li>将 <code>file2</code> 移动到上级目录</li>
<li>删除 <code>file2</code> 和 <code>new_file1</code></li>
<li>创建文件夹 <code>dir1</code></li>
<li>删除 <code>dir1</code></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文件搜索"><a class="header" href="#文件搜索">文件搜索</a></h1>
<p>熟练使用查找命令可以节省很多时间并提高工作效率，涉及搜索的主要工具是 <code>find</code> 等实用程序。</p>
<h2 id="标准文件流"><a class="header" href="#标准文件流">标准文件流</a></h2>
<p>在执行命令时，默认情况下有三个标准文件流始终打开以供使用：标准输入 <strong><code>stdin</code></strong>、标准输出 <strong><code> stdout</code></strong> 和标准错误   <strong><code>stderr</code></strong>。</p>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>符号名</th><th>值</th><th>示例</th></tr></thead><tbody>
<tr><td>标准输入</td><td><strong><code>stdin</code></strong></td><td>0</td><td>键盘</td></tr>
<tr><td>标准输出</td><td><strong><code>stdout</code></strong></td><td>1</td><td>终端</td></tr>
<tr><td>标准错误</td><td><strong><code>stderr</code></strong></td><td>2</td><td>日志</td></tr>
</tbody></table>
</div>
<p><strong><code>stdin</code></strong> 通常是键盘，<strong><code>stdout</code></strong> 和 <strong><code>stderr</code></strong> 通常打印在终端上。利用重定向，也可以将某个文件作为输入 <strong><code>stdin</code></strong>，并将输出 <strong><code>stdout</code></strong> 定向到另一个文件，<strong><code>stderr</code></strong> 通常定向到错误日志文件。</p>
<p>在 Linux 中，所有打开的文件都由所谓的<strong>文件描述符</strong>（file descriptor）在内部表示的并从零开始，<strong><code>stdin</code></strong> 是 <code>0</code>，<strong><code>stdout</code></strong> 是 <code>1</code>，<strong><code>stderr</code></strong> 是 <code>2</code>。如果还打开了其他文件，则文件描述符继续从 3 开始，并依次增加。</p>
<h2 id="重定向"><a class="header" href="#重定向">重定向</a></h2>
<p>通过 Shell，我们可以重定向三个标准文件流，这样我们就可以从一个文件或另一个命令中获得输入，而不是从键盘获得输入。我们可以将输出和错误写入文件，或者用于为后续命令提供输入。</p>
<p>例如，可以使用 <code>&gt;</code> 符号将 <code>hello</code> 输出定向到某个文件：</p>
<pre><code>./hello &gt; anyfile
</code></pre>
<p>使用 <code>&lt;</code> 符号将某个文件作为输入：</p>
<pre><code>cat &lt; hello.c
</code></pre>
<p>输入输出还可以组合使用：</p>
<pre><code>./add &lt; infile &gt; outfile
</code></pre>
<p>对于 <code>stderr</code> 需要明确指定文件描述符的值：</p>
<pre><code>./add 2&gt; errfile
</code></pre>
<p>如果打算将 <code>stderr</code> 输出到 <code>stdout</code>，则可以使用：</p>
<pre><code>./add &gt; outfile 2&gt;&amp;1
</code></pre>
<h2 id="管道"><a class="header" href="#管道">管道</a></h2>
<p>UNIX/Linux 的理念是设计许多简单而简短的程序或命令，协同工作来解决复杂的任务，而不是设计一个复杂的程序，通过不同的选项和模式来完成。为了实现这一点，UNIX/Linux 大量使用<strong>管道</strong>来实现这一目的，通过管道可以将一个命令或程序的输出作为另一个命令或程序的输入。</p>
<p>可以通过管道符号 <code>|</code> 来实现管道操作：</p>
<pre><code>$ cmd1 | cmd2 | cmd3
</code></pre>
<p>以上命令非常有效，因为 <code>cmd2</code> 和 <code>cmd3</code> 不必等待先前的管道命令完成，就可以开始处理其输入流中的数据；特别是在多核心系统上，可用的计算能力得到了更好的利用。</p>
<p>另一点是，管道之间的输入输出无需存储到硬盘上，硬盘的读写同样效率低下。</p>
<h2 id="查找"><a class="header" href="#查找">查找</a></h2>
<p><strong><code>find</code></strong> 是 Linux 系统管理员日常生活中非常有用且经常使用的实用程序。它可以从任意特定目录（或目录集）向下递归文件系统，并定位符合指定条件的文件，默认路径名始终为当前工作目录。</p>
<p>例如，管理员有时会花几周的时间扫描的一个潜在的核心文件，以便将其删除。有时候也用于清理临时目录 <code>/tmp</code> 或缓存目录 <code>/var/cache/</code> 中的非必要文件。许多发行版也内置一些脚本程序，定期清理这些目录。</p>
<p><img src="topic_0/./assets/find.png" alt="find" /></p>
<p>不指定参数的情况下，<code>find</code> 会递归列出当前目录下所有的文件。常用的选项有：</p>
<ul>
<li>
<p><code>-name</code> 列出包含某个字符串的文件</p>
<pre><code>find /usr -name gcc
</code></pre>
</li>
<li>
<p><code>-iname</code> 列出不包含某个字符串的文件</p>
<pre><code>find /usr -iname gcc
</code></pre>
</li>
<li>
<p><code>-type</code> 限定文件的类型，例如 <code>d</code> 表示目录，<code>l</code> 表示符号链接，<code>f</code> 表示普通文件</p>
<pre><code>find /usr -type d -name gcc
</code></pre>
<pre><code>find /usr -type f -name gcc
</code></pre>
</li>
</ul>
<p><code>find</code> 的另一个用途是能够在符合搜索条件的文件上运行命令，需要使用选型 <code>-exec</code>。例如，查找并删除 <code>.swp</code> 后缀的文件：</p>
<pre><code>find -name &quot;*.swp&quot; -exec rm {} ';'
</code></pre>
<p>其中 <code>{}</code> 充当占位符，用于替换搜索到的文件名。需要注意的是，命令必须以 <code>';'</code> 或 <code>\;</code> 结尾。</p>
<h2 id="练习-2"><a class="header" href="#练习-2">练习</a></h2>
<p>以 <code>/</code> 开头，搜索包含 <code>init.d</code> 的文件。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="从-c-到-c"><a class="header" href="#从-c-到-c">从 C++ 到 C</a></h1>
<p>本节我们会使用 C 语言复习 CS101 中的一些概念，并改写一些 C++ 程序，逐步上手 C 语言的开发。</p>
<p>相信大家还记得 CS101 库中的两个重要的接口工具 <a href="https://cppdoc.stickmind.com/strlib.html"><code>strlib.h</code></a> 和 <a href="https://cppdoc.stickmind.com/filelib.html"><code>filelib.h</code></a>。这些抽象接口极大地方便了我们编写字符串处理和文件 I/O 相关的程序。所以在本课程的教学方式上，我们依然遵循抽象思维的观念，避免较早地涉及底层的细节。在入门示例中，重点抽象了以下两个类型 <code>string</code> 和 <code>stream</code>，以便在不涉及指针的情况下，就能完成字符串和文件的处理工作。</p>
<p>希望通过这样的方式，方便大家对比学习，能够将现有的知识迁移到新的语境中。</p>
<pre><code class="language-c">/*
 * Type: string
 * ------------
 * The type string is identical to the type char *, which is
 * traditionally used in C programs.  The main point of defining a
 * new type is to improve program readability.   At the abstraction
 * levels at which the type string is used, it is usually not
 * important to take the string apart into its component characters.
 * Declaring it as a string emphasizes this atomicity.
 */

typedef char* string;

/*
 * Type: stream
 * ------------
 * Like string, the stream type is used to provide additional
 * readability and is defined to be equivalent to FILE *
 * (which is particularly confusing because it violates
 * standard case conventions).
 */

typedef FILE* stream;
</code></pre>
<p>为了照顾部分编程基础较为薄弱的同学，本次课程也会引入 <strong>CMake</strong> 并介绍一种较为方便的 <strong>VS Code</strong> 开发工作流，方便大家课后自行练习、巩固。</p>
<h2 id="练习-3"><a class="header" href="#练习-3">练习</a></h2>
<p>下载群文件中的 <code>230915-cslib/cslib.zip</code> 文件，尝试使用 <strong>CMake</strong> 工具，将 <code>.h</code> 和 <code>.c</code> 组成的文件集合打包成静态库。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simpioh"><a class="header" href="#simpioh">simpio.h</a></h1>
<p>该接口导出几个函数来简化输入数据的读取。</p>
<h2 id="接口"><a class="header" href="#接口">接口</a></h2>
<div class="table-wrapper"><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>GetInteger()</code></td><td>从标准输入读取一行文本并将其作为 <code>int</code> 整数返回</td></tr>
<tr><td><code>GetLong()</code></td><td>从标准输入读取一行文本并将其作为 <code>long</code> 整数返回</td></tr>
<tr><td><code>GetReal()</code></td><td>从标准输入读取一行文本并将其作为 <code>double</code> 浮点数返回</td></tr>
<tr><td><code>GetLine()</code></td><td>从标准输入读取一行文本并将其作为字符串返回</td></tr>
<tr><td><code>ReadLine(infile)</code></td><td>从输入文件中读取一行文本并将该行作为字符串返回</td></tr>
</tbody></table>
</div>
<h2 id="接口详情"><a class="header" href="#接口详情">接口详情</a></h2>
<pre><code class="language-c">/*
 * Function: GetInteger
 * Usage: i = GetInteger();
 * ------------------------
 * GetInteger reads a line of text from standard input and scans
 * it as an integer.  The integer value is returned.  If an
 * integer cannot be scanned or if more characters follow the
 * number, the user is given a chance to retry.
 */

int GetInteger(void);

/*
 * Function: GetLong
 * Usage: l = GetLong();
 * ---------------------
 * GetLong reads a line of text from standard input and scans
 * it as a long integer.  The value is returned as a long.
 * If an integer cannot be scanned or if more characters follow
 * the number, the user is given a chance to retry.
 */

long GetLong(void);

/*
 * Function: GetReal
 * Usage: x = GetReal();
 * ---------------------
 * GetReal reads a line of text from standard input and scans
 * it as a double.  If the number cannot be scanned or if extra
 * characters follow after the number ends, the user is given
 * a chance to reenter the value.
 */

double GetReal(void);

/*
 * Function: GetLine
 * Usage: s = GetLine();
 * ---------------------
 * GetLine reads a line of text from standard input and returns
 * the line as a string.  The newline character that terminates
 * the input is not stored as part of the string.
 */

string GetLine(void);

/*
 * Function: ReadLine
 * Usage: s = ReadLine(infile);
 * ----------------------------
 * ReadLine reads a line of text from the input file and
 * returns the line as a string.  The newline character
 * that terminates the input is not stored as part of the
 * string.  The ReadLine function returns NULL if infile
 * is at the end-of-file position.
 */

string ReadLine(stream infile);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simpioh-1"><a class="header" href="#simpioh-1">simpio.h</a></h1>
<p>该接口定义了动态分配字符串的通用库。传统 C 字符串与使用此接口定义的字符串之间的主要区别是：</p>
<ul>
<li><code>strlib.h</code> 接口负责内存分配，确保有足够的空间来保存每个字符串操作的结果。</li>
<li><code>strlib.h</code> 接口的客户端应将所有字符串视为不可变，并避免写入字符数组。</li>
</ul>
<h2 id="接口-1"><a class="header" href="#接口-1">接口</a></h2>
<div class="table-wrapper"><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>ConcatString(s1, s2)</code></td><td>通过将两个字符串首尾相连进行连接</td></tr>
<tr><td><code>IthChar(s, i)</code></td><td>返回字符串 <code>s</code> 中位置 <code>i</code> 的字符</td></tr>
<tr><td><code>SubString(s, p1, p2)</code></td><td>返回 <code>s</code> 索引区间为 <code>[p1, p2]</code> 的子字符串</td></tr>
<tr><td><code>CharToString(ch)</code></td><td>接受单个字符并返回由该字符组成的单字符字符串</td></tr>
<tr><td><code>StringLength(s)</code></td><td>返回字符串 <code>s</code> 的长度</td></tr>
<tr><td><code>CopyString(s)</code></td><td>将字符串 <code>s</code> 复制到动态内存中并返回新字符串</td></tr>
<tr><td><code>StringEqual(s1, s2)</code></td><td>如果字符串 <code>s1</code> 和 <code>s2</code> 相等，则返回 true</td></tr>
<tr><td><code>StringCompare(s1, s2)</code></td><td>如果字符串 <code>s1</code> 按字典顺序位于 <code>s2</code> 之前，则返回 <code>-1</code>；如果相等，则返回 <code>0</code>；如果 <code>s1</code> 位于 <code>s2</code> 之后，则返回 <code>+1</code></td></tr>
<tr><td><code>FindChar(ch, text, start)</code></td><td>从位置 <code>start</code> 开始，在字符串 <code>text</code> 中搜索的字符 <code>ch</code>，并返回该字符出现的第一个索引；如果未找到匹配项，则返回 <code>-1</code></td></tr>
<tr><td><code>FindString(str, text, start)</code></td><td>从位置 <code>start</code> 开始，在字符串 <code>text</code> 中搜索字符串 <code>str</code>，并返回该字符串出现的第一个索引；如果未找到匹配项，则返回 <code>-1</code></td></tr>
<tr><td><code>ConvertToLowerCase(s)</code></td><td>返回一个新字符串，其中所有字母字符都转换为小写</td></tr>
<tr><td><code>ConvertToUpperCase(s)</code></td><td>返回一个新字符串，其中所有字母字符都转换为大写</td></tr>
<tr><td><code>IntegerToString(n)</code></td><td>将整数转换为相应的数字字符串</td></tr>
<tr><td><code>StringToInteger(s)</code></td><td>将数字字符串转换为整数</td></tr>
<tr><td><code>RealToString(d)</code></td><td>将浮点数转换为相应的数字字符串</td></tr>
<tr><td><code>StringToReal(s)</code></td><td>将数字字符串转换为浮点数</td></tr>
</tbody></table>
</div>
<h2 id="接口详情-1"><a class="header" href="#接口详情-1">接口详情</a></h2>
<pre><code class="language-c">/* Section 1 -- Basic string operations */

/*
 * Function: ConcatString
 * Usage: s = ConcatString(s1, s2);
 * --------------------------
 * This function concatenates two strings by joining them end
 * to end.  For example, ConcatString(&quot;ABC&quot;, &quot;DE&quot;) returns the string
 * &quot;ABCDE&quot;.
 */

string ConcatString(string s1, string s2);

/*
 * Function: IthChar
 * Usage: ch = IthChar(s, i);
 * --------------------------
 * This function returns the character at position i in the
 * string s.  It is included in the library to make the type
 * string a true abstract type in the sense that all of the
 * necessary operations can be invoked using functions. Calling
 * IthChar(s, i) is like selecting s[i], except that IthChar
 * checks to see if i is within the range of legal index
 * positions, which extend from 0 to StringLength(s).
 * IthChar(s, StringLength(s)) returns the null character
 * at the end of the string.
 */

char IthChar(string s, int i);

/*
 * Function: SubString
 * Usage: t = SubString(s, p1, p2);
 * --------------------------------
 * SubString returns a copy of the substring of s consisting
 * of the characters between index positions p1 and p2,
 * inclusive.  The following special cases apply:
 *
 * 1. If p1 is less than 0, it is assumed to be 0.
 * 2. If p2 is greater than the index of the last string
 *    position, which is StringLength(s) - 1, then p2 is
 *    set equal to StringLength(s) - 1.
 * 3. If p2 &lt; p1, SubString returns the empty string.
 */

string SubString(string s, int p1, int p2);

/*
 * Function: CharToString
 * Usage: s = CharToString(ch);
 * ----------------------------
 * This function takes a single character and returns a
 * one-character string consisting of that character.  The
 * CharToString function is useful, for example, if you
 * need to concatenate a string and a character.  Since
 * ConcatString requires two strings, you must first convert
 * the character into a string.
 */

string CharToString(char ch);

/*
 * Function: StringLength
 * Usage: len = StringLength(s);
 * -----------------------------
 * This function returns the length of s.
 */

int StringLength(string s);

/*
 * Function: CopyString
 * Usage: newstr = CopyString(s);
 * ------------------------------
 * CopyString copies the string s into dynamically allocated
 * storage and returns the new string.  This function is not
 * ordinarily required if this package is used on its own,
 * but is often necessary when you are working with more than
 * one string package.
 */

string CopyString(string s);

/* Section 2 -- String comparison functions */

/*
 * Function: StringEqual
 * Usage: if (StringEqual(s1, s2)) ...
 * -----------------------------------
 * This function returns true if the strings s1 and s2 are
 * equal.  For the strings to be considered equal, every
 * character in one string must precisely match the
 * corresponding character in the other.  Uppercase and
 * lowercase characters are considered to be different.
 */

bool StringEqual(string s1, string s2);

/*
 * Function: StringCompare
 * Usage: if (StringCompare(s1, s2) &lt; 0) ...
 * -----------------------------------------
 * This function returns a number less than 0 if string s1
 * comes before s2 in alphabetical order, 0 if they are equal,
 * and a number greater than 0 if s1 comes after s2.  The
 * ordering is determined by the internal representation used
 * for characters, which is usually ASCII.
 */

int StringCompare(string s1, string s2);

/* Section 3 -- Search functions */

/*
 * Function: FindChar
 * Usage: p = FindChar(ch, text, start);
 * -------------------------------------
 * Beginning at position start in the string text, this
 * function searches for the character ch and returns the
 * first index at which it appears or -1 if no match is
 * found.
 */

int FindChar(char ch, string text, int start);

/*
 * Function: FindString
 * Usage: p = FindString(str, text, start);
 * ----------------------------------------
 * Beginning at position start in the string text, this
 * function searches for the string str and returns the
 * first index at which it appears or -1 if no match is
 * found.
 */

int FindString(string str, string text, int start);

/* Section 4 -- Case-conversion functions */

/*
 * Function: ConvertToLowerCase
 * Usage: s = ConvertToLowerCase(s);
 * ---------------------------------
 * This function returns a new string with all
 * alphabetic characters converted to lower case.
 */

string ConvertToLowerCase(string s);

/*
 * Function: ConvertToUpperCase
 * Usage: s = ConvertToUpperCase(s);
 * ---------------------------------
 * This function returns a new string with all
 * alphabetic characters converted to upper case.
 */

string ConvertToUpperCase(string s);

/* Section 5 -- Functions for converting numbers to strings */

/*
 * Function: IntegerToString
 * Usage: s = IntegerToString(n);
 * ------------------------------
 * This function converts an integer into the corresponding
 * string of digits.  For example, IntegerToString(123)
 * returns &quot;123&quot; as a string.
 */

string IntegerToString(int n);

/*
 * Function: StringToInteger
 * Usage: n = StringToInteger(s);
 * ------------------------------
 * This function converts a string of digits into an integer.
 * If the string is not a legal integer or contains extraneous
 * characters, StringToInteger signals an error condition.
 */

int StringToInteger(string s);

/*
 * Function: RealToString
 * Usage: s = RealToString(d);
 * ---------------------------
 * This function converts a floating-point number into the
 * corresponding string form.  For example, calling
 * RealToString(23.45) returns &quot;23.45&quot;.  The conversion is
 * the same as that used for &quot;%G&quot; format in printf.
 */

string RealToString(double d);

/*
 * Function: StringToReal
 * Usage: d = StringToReal(s);
 * ---------------------------
 * This function converts a string representing a real number
 * into its corresponding value.  If the string is not a
 * legal floating-point number or if it contains extraneous
 * characters, StringToReal signals an error condition.
 */

double StringToReal(string s);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pig-latin"><a class="header" href="#pig-latin">Pig Latin</a></h1>
<p>本节通过一个简化的 C 程序复习模块化开发和逐步求精的过程。<strong>模块化开发</strong>就是把一个程序分成多个模块的技术，回忆下 CS101 作业 1 中 <code>soundex</code> 的处理过程，模块通过一系列函数实现功能拆分。</p>
<p>通过该案例，我们也可以了解从 C++ 转到 C 的一些变化，例如，如何维护状态信息？如何保持状态的私有性？</p>
<h2 id="任务说明"><a class="header" href="#任务说明">任务说明</a></h2>
<p>Pig Latin 是按照如下简单的规则转换每个英文单词，从而创造一门新的语言：</p>
<ul>
<li>如果单词以辅音开头，则将第一个元音字母前的所有辅音字符串移到末尾，并加上 <code>ay</code></li>
<li>如果单词以元音开头，则加上 <code>way</code></li>
</ul>
<p>例如，单词 <code>scram</code> 符合第一条规则，所以将 <code>scr</code> 移动到尾部并加上 <code>ay</code>，结果就是 <code>amscray</code>。单词 <code>apple</code> 符合第二条规则，所以直接加上 <code>way</code>，结果就是 <code>appleway</code>。</p>
<h2 id="任务-1实现交互程序"><a class="header" href="#任务-1实现交互程序">任务 1：实现交互程序</a></h2>
<p>程序执行时会提示用户输入一段文字，然后程序能够生产如下的结果：</p>
<pre><code>Enter a line: this is pig latin.
isthay isway igpay atinlay.
</code></pre>
<p>我们采用自顶向下实现，可以不用一开始就决定如何将程序分割成多个模块。在实现交互程序时，可以先假设有一个接口，能够将一行字符串转换成 Pig Latin：</p>
<pre><code class="language-c">/*
 * Function: TranslateLine
 * Usage: TranslateLine(line);
 * ---------------------------
 * This function takes a line of text and translates
 * the words in the line to Pig Latin, displaying the
 * translation as it goes.
 */

void TranslateLine(string line);
</code></pre>
<p>以抽象思维开发程序，我们已经能够实现程序的交互部分了。</p>
<details>
  <summary>💡Hint</summary>
<pre><code class="language-c">int main(int argc, string args[]) {
  printf(&quot;Enter a line: &quot;);
  string line = GetLine();
  TranslateLine(line);
}
</code></pre>
</details>
<h2 id="任务-2实现-translateline"><a class="header" href="#任务-2实现-translateline">任务 2：实现 TranslateLine</a></h2>
<p>实现 TranslateLine 将转变抽象层级，此时我们作为开发者将提供上述接口。在这个层级上，问题依然复杂，需要进一步将问题拆解。</p>
<p>TranslateLine 需要做的工作大致可以分为 3 步：</p>
<ul>
<li>如何将一个字符串拆分成独立的单词</li>
<li>按规则将每个单词转换成 Pig Latin</li>
<li>显示转换后的单词，并以换行符结尾</li>
</ul>
<details>
  <summary>💡Hint</summary>
<hr />
<p>如果以容器的思想，如何拆分上述步骤？</p>
<p>C 虽然没有提供直接使用的容器，但使用动态数组，我们也能够完成同样的任务。这里为了简便起见，我们不需要存储每个单词，一旦翻译完成就立刻显示结果，并处理下一个单词。</p>
<hr />
</details>
<p>回顾 CS101 中作业 2 的 <code>search</code> 程序，对单词的处理一般是通过 <code>token</code> 来完成的。比如，这样的输入行：</p>
<blockquote>
<p>this is pig latin.</p>
</blockquote>
<p>可以看作是以下 8 个 <code>token</code> 组成：</p>
<p><img src="topic_0/./assets/token.png" alt="token" /></p>
<p>可以看出，除了单词，<code>token</code> 还包括一些标点组成的字符。在处理 <code>token</code> 是需要进行判断，这里我们假设有一个谓词函数接口 <code>IsLegalWord</code> 可以直接使用。</p>
<p>同样为了简便起见，我们提供了一份 C 版本的 <code>tokenscanner</code> 接口库。</p>
<div class="table-wrapper"><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>InitScanner(line)</code></td><td>初始化扫描器，以便从开头读取每个 <code>token</code></td></tr>
<tr><td><code>GetNextToken()</code></td><td>返回下一个 <code>token</code></td></tr>
<tr><td><code>AtEndOfLine()</code></td><td>如果扫描器到达末尾，返回 <code>true</code></td></tr>
</tbody></table>
</div>
<p>常用的编程习语可以参考如下的循环结构。其中，<code>InitScanner</code> 初始化后，<code>GetNextToken</code> 将能够获取第一个单词。如果 <code>AtEndOfLine</code>，扫描器将会重复相同的处理逻辑。</p>
<pre><code class="language-c">InitScanner(line);
while (!AtEndOfLine()) {
   token = GetNextToken();
   ... 处理 token 记号 ...
}
</code></pre>
<p>在 <code>tokenscanner</code> 的帮助下，我们进一步拆分了 <code>TranslateLine</code> 处理逻辑，将翻译的工作交给 <code>TranslateWord</code> 处理。</p>
<details>
  <summary>💡Hint</summary>
<pre><code class="language-c">void TranslateLine(string line) {
  InitScanner(line);
  while (!AtEndOfLine()) {
      string token = GetNextToken();
      if (IsLegalWord(token))
          token = TranslateWord(token);
      printf(&quot;%s&quot;, token);
  }
  printf(&quot;\n&quot;);
}
</code></pre>
</details>
<h2 id="任务-3实现-islegalword-和-translateword"><a class="header" href="#任务-3实现-islegalword-和-translateword">任务 3：实现 IsLegalWord 和 TranslateWord</a></h2>
<p>完成 <code>TranslateLine</code> 的拆解后，我们的工作只剩下 <code>token</code> 处理的几个函数。</p>
<p><code>IsLegalWord</code> 相对比较容易，我们只需要借助 <code>ctype.h</code> 接口提供的 <a href="https://en.cppreference.com/w/c/string/byte/isalpha"><code>isalpha</code></a> 函数就能够判断 <code>token</code> 是否为有效单词。</p>
<details>
  <summary>💡Hint</summary>
<pre><code class="language-c">bool IsLegalWord(string token) {
  for (int i = 0; i &lt; StringLength(token); i++) {
      if (!isalpha(IthChar(token, i)))
          return (false);
  }
  return (true);
}
</code></pre>
</details>
<p><code>TranslateWord</code> 稍微复杂一些，根据规则你需要判断第一个元音字母的位置：如果位置为 0，则按照规则 1 处理；如果不为 0，则按照规则 2 处理。</p>
<p>那么如何判断元音字母呢？检查 <code>strlib.h</code> 接口，我们并没有发现现成的函数可以使用。此时，扩充该接口就很有必要了，因为判断元音的操作相当常见。</p>
<p>剩下的实现相对比较容易，合理使用 <code>strlib.h</code> 接口，我们可以完成这个任务。</p>
<details>
  <summary>💡Hint</summary>
<pre><code class="language-c">string TranslateWord(string word) {
  int vp = FindFirstVowel(word);
  if (vp == -1) {
      return (word);
  } else if (vp == 0) {
      return (ConcatString(word, &quot;way&quot;));
  } else {
      string head = SubString(word, 0, vp - 1);
      string tail = SubString(word, vp, StringLength(word) - 1);
      return (ConcatString(tail, ConcatString(head, &quot;ay&quot;)));
  }
}

int FindFirstVowel(string word) {
  for (int i = 0; i &lt; StringLength(word); i++) {
      if (IsVowel(IthChar(word, i)))
          return (i);
  }
  return (-1);
}
</code></pre>
</details>
<h2 id="思考"><a class="header" href="#思考">思考</a></h2>
<ol>
<li>为什么 <code>GetNextToken</code> 不需要提供 <code>line</code> 参数？</li>
<li>循环结构中，<code>GetNextToken</code> 每次调用，都会从 <code>line</code> 的不同位置开始，这是如何做到的？</li>
<li>如何避免外部程序调用我们拆分的这些辅助函数？</li>
</ol>
<h2 id="推荐阅读"><a class="header" href="#推荐阅读">推荐阅读</a></h2>
<p>更多 C 和 C++ 的不同之处，可以参考 <a href="http://www.cs.ecu.edu/karl/4627/spr18/C.html">http://www.cs.ecu.edu/karl/4627/spr18/C.html</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实验-0上手-linux-开发环境"><a class="header" href="#实验-0上手-linux-开发环境">实验 0：上手 Linux 开发环境</a></h1>
<p>本课程开发环境选用远程 Linux 云端服务器和命令行工具，搭配本地终端和 VS Code 即可完成所有练习。</p>
<p>本次实验将带大家练习远程开发的流程，实验结束后，你应该能够连接上课程的远程服务器，并能够使用终端命令，搭配 VS Code 进行代码编辑。</p>
<blockquote>
<p><strong>❓FAQ</strong> 为什么使用远程服务器进行开发？</p>
<p>如果回到上个世纪 80 年代，即使电脑就在你的面前，你也必须使用终端才能对计算机进行操作。现如今，随着个人计算机的发展，虽然图形界面早已成熟，但在真实的开发场景中，使用终端开发仍然占据主导地位。大量的前后端框架、开源项目、开发工具，也严重依赖终端操作。</p>
<p>本课程尽量还原类似的真实开发场景。当你以后有机会去软件公司实习时，你会发现，在这里掌握的技能，将会给你带来极大的回报。</p>
</blockquote>
<h2 id="登录课程云服务器"><a class="header" href="#登录课程云服务器">登录课程云服务器</a></h2>
<p>服务器 IP 地址为 <code>106.14.165.94</code>，在任何支持 <code>ssh</code> 命令的<strong>计算机终端</strong><sup class="footnote-reference"><a href="#1">1</a></sup>上输入如下命令。</p>
<ul>
<li>Window 11 已搭载 Windows Terminal</li>
<li>Linux/macOS 内置 Terminal</li>
</ul>
<pre><code>ssh YourName@106.14.165.94
</code></pre>
<p>第一次使用会弹出确认信息，输入 <code>yes</code> 后紧接着输入服务器用户密码（输入过程中，密码不会显示），成功后的输出信息如下。</p>
<pre><code>The authenticity of host '106.14.165.94 (106.14.165.94)' can't be established.
ED25519 key fingerprint is SHA256:LHvn4qDvTdM1+GcJtG2f+uywxDA2JSys.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes

Warning: Permanently added '106.14.165.94' (ED25519) to the list of known hosts.
YourName@106.14.165.94's password:     

Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-52-generic x86_64)
</code></pre>
<p>查看服务器信息常用命令</p>
<ul>
<li>查看主机名：<code>hostname</code></li>
<li>查看用户名：<code>whoami</code></li>
<li>查看硬盘空间：<code>df -h</code> （仅 <code>root</code> 权限）</li>
<li>查看内存状态：<code>free -h</code></li>
<li>查看当前文件夹空间：<code>du --max-depth=1 -h</code></li>
<li>修改登录密码：<code>passwd</code></li>
</ul>
<h2 id="基于-sftp-远程开发工作流"><a class="header" href="#基于-sftp-远程开发工作流">基于 SFTP 远程开发工作流</a></h2>
<p>使用命令行成功登录服务器后，说明你的计算机已经包含了 SSH 等工具。为了便于开发，可以使用流行的 VS Code 文本编辑器辅助编辑、同步项目代码。</p>
<blockquote>
<p><strong>❓FAQ</strong> 为什么本课程不推荐使用 VS Code 官方 Remote 插件？</p>
<p>如果使用官方 Remote 插件，一旦连接服务器，VS Code 会在 <code>home</code> 目录不断生成 <code>.vscode-server</code> 垃圾文件，严重的时候甚至达到几个 GB 的空间。</p>
<p>除此之外，官方 Remote 插件内存占用也比较高，每个用户都会消耗几百 MB 的内存资源。</p>
<p>如此高的资源消耗，即便国内外各大高校自建的校内服务器，也无法承受。</p>
<p><em>参考：<a href="https://github.com/microsoft/vscode-remote-release/issues/6429">Copies of vscode-server installed on school servers take up excessive storage and RAM</a></em></p>
</blockquote>
<h2 id="安装-sftp-插件"><a class="header" href="#安装-sftp-插件">安装 SFTP 插件</a></h2>
<p>在 VS Code 插件市场搜索 <code>SFTP</code>，选择安装 Natizyskunk 开发的 <code>SFTP</code> 插件，如图所示。</p>
<p><img src="topic_0/./assets/sftp.png" alt="sftp" /></p>
<h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<p>安装完插件之后，可以使用本课程提供的初始项目 <code>starter-proj.zip</code>，该项目已设置好 VS Code 和 <code>SFTP</code> 配置框架。解压后使用 VS Code 打开 <code>starter-proj</code> 文件夹。在 <code>.vscode</code> 文件夹下，编辑 <code>sftp.json</code> 文件修改以下几个信息：</p>
<ul>
<li><code>username</code>：服务器用户名</li>
<li><code>password</code>：服务器密码</li>
<li><code>remotePath</code>：服务器上需要编辑的项目路径，例如 <code>/home/xuehao/cs102/lab0/</code></li>
</ul>
<p><img src="topic_0/./assets/sftp_config.png" alt="sftp-config" /></p>
<h2 id="使用"><a class="header" href="#使用">使用</a></h2>
<blockquote>
<p><strong>⚠️注意</strong></p>
<p>参照上一步配置的 <code>remotePath</code>，必须先在服务器上提前创建好这些目录，才能进行接下来的操作。</p>
</blockquote>
<p>配置好后，点击 VS Code 菜单栏 <strong>Help</strong> 选择 <strong>Show All Commands</strong>，或直接按 <strong>F1</strong> 快捷键，在弹出的命令列表中搜索 SFTP。选择 &quot;<strong>SFTP: Download Project</strong>&quot;，随后选择默认保存位置，远程服务器中的项目将会自动下载到本地的初始项目文件夹中。</p>
<p><img src="topic_0/./assets/using_sftp.png" alt="sftp-use" /></p>
<p>在本地编辑完文件并保存后，SFTP 插件会自动将更新后的文件同步到远程服务器。编译、测试、调试等任务，可以通过终端 Terminal 在远程服务器上进行。</p>
<blockquote>
<p><strong>⚠️注意</strong></p>
<p><strong>添加文件</strong>：如果之前没有创建任何项目文件，那么当你在本地或服务器中创建文件时，并不会自动同步。此时可以使用 &quot;<strong>SFTP: Sync Remote -&gt; Local</strong>&quot; 或 &quot;<strong>SFTP: Sync Local -&gt; Remote</strong>&quot; 手动同步。</p>
<p><strong>删除文件</strong>：删除文件比较特殊，以上三条命令，对删除文件不起作用。如果有文件需要删除，必须在本地和服务器中分别手动删除。</p>
</blockquote>
<blockquote>
<p><strong>⚠️注意</strong></p>
<p>如果不小心使用 VS Code 官方远程插件，可以使用 <code>ls -a</code> 命令查看你的服务器目录，此时你会发现一个 <code>.vscode-server</code> 文件夹。</p>
<p>可以使用使用 <code>rm -r .vscode-server</code> 命令删除该目录。</p>
</blockquote>
<blockquote>
<p><strong>⚠️注意</strong></p>
<p>严禁使用 Jetbrains Clion/Fleet 连接服务器！一旦连接，此类开发工具会在服务器上下载超过 2 GB 的 Java 依赖。</p>
</blockquote>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://wiki.mbalib.com/wiki/%E7%BB%88%E7%AB%AF%EF%BC%88%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%89">终端</a>是一台电子计算机或者计算机系统，用来让用户输入数据，及显示其计算结果的机器。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="上手-linux-和-c"><a class="header" href="#上手-linux-和-c">上手 Linux 和 C</a></h1>
<blockquote>
<p><em>本次作业参考：<a href="https://web.stanford.edu/class/archive/cs/cs107/cs107.1206/assign0/">CS107, Spring 2020 Assignment 0: Intro to Unix and C</a></em></p>
</blockquote>
<p>Linux 的使用和命令行操作需要不断地练习。熟练使用这些工具，才能更好地完成作业练习。但要注意的是，这些内容不需要刻意去记忆，经过一段时间的重复使用，自然可以掌握。</p>
<p>在开始作业之前，确保你已经能够：</p>
<ul>
<li>登陆课程服务器</li>
<li>管理文件，浏览服务器文件系统
<ul>
<li>能够找到实验、作业的初始项目</li>
<li>能够合理地管理课程代码，避免杂乱无章</li>
</ul>
</li>
<li>通过 VS Code 等编辑器修改服务器上的文件</li>
<li>逐步适应 Shell 和命令行的工作流
<ul>
<li>遇到不熟悉的命令，知道去哪里学习</li>
<li>会用 <code>tab</code>、上下键等快捷操作避免输入太多命令</li>
</ul>
</li>
</ul>
<p>本次作业目的是检验大家是否熟练使用 Linux 开发环境，能够适应编辑、构建、运行、测试 C 程序的工作流。</p>
<h2 id="初始项目"><a class="header" href="#初始项目">初始项目</a></h2>
<p>建议在个人目录创建一个 <code>cs102</code> 的文件夹，用于管理课程所有的代码。然后可以使用下面的命令，将作业的初始文件复制到该目录。</p>
<pre><code>cp -r /home/cs102-shared/assignments/assign0 ~/cs102
</code></pre>
<p>别忘了通过 VS Code 将文件同步到本地查看、编辑。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入侵者检测"><a class="header" href="#入侵者检测">入侵者检测</a></h1>
<blockquote>
<p>在该任务中，你将调查一起模拟的入侵攻击并回答 <code>readme.txt</code> 中的几个小问题。每个问题只需要简短的几句话即可，描述你用了什么样的 Linux 命令解决的。</p>
</blockquote>
<p>入侵者访问了我们的服务器，并删除了很多文件。幸运的是，这些文件在服务器上都有备份，但在恢复文件之前，你要调查一下入侵者的身份并看看他们做了哪些破坏性操作。</p>
<p>在服务器 <code>/home/server_files</code> 中包含了一些核心的文件，使用文件操作命令查看有哪些内容。</p>
<p>你需要先调查攻击者的身份。服务器可以供多个用户使用，每个用户的名字都在上述路径的 <code>home</code> 子目录中。例如，用户 <code>bob</code> 的路径是 <code>/home/bob</code>。文件 <code>users.list</code> 包含了认证用户的列表，<code>home</code> 子目录中的用户目录应该和该文件中的用户名一一对应。入侵者是未认证用户，所以他的名字不会出现在<code>users.list</code> 列表中。</p>
<p>你的任务就是找出这个入侵用户名！由于用户列表很多，通过手工比对不太现实，合适的命令行工具可以更快地完成这个任务。</p>
<details>
  <summary><b>提示</b></summary>
<hr />
<ul>
<li>可以考虑创建一个临时文件用于存储中间数据，但更推荐使用管道来优化操作。</li>
<li>自学 <code>diff</code> 命令的用法，看有没有什么启发。</li>
</ul>
<hr />
</details>
<p>如果你已经知道入侵者的名字，那么检查一下他的用户目录，看看有什么新的发现。虽然入侵者删除了目录下的文件，但似乎这个目录依然占用了一部分空间。想一想这是为什么？用命令行工具验证一下。</p>
<p>对了，以 <code>.</code> 开头的文件在 Linux 系统中属于隐藏文件，显示这些文件需要一些特殊的参数。在这些隐藏的文件中，有一个文件记录了入侵者所有的活动记录，这个文件是什么呢？它包含了什么内容？</p>
<p>如果想对系统实施破坏行为，必须使用 <code>sudo</code> 权限执行某些命令。在上述文件中，你会发现整个活动记录非常长，很难发现哪些命令用到了特权权限。用什么命令可以方便地提取出这些信息？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="谢尔宾斯基分形"><a class="header" href="#谢尔宾斯基分形">谢尔宾斯基分形</a></h1>
<blockquote>
<p>通过该任务，我们可以练习远程开发工作流：编辑、构建、运行、测试。</p>
</blockquote>
<p>在 <code>assign0</code> 文件夹中，输入 <code>make</code> 将构建名为 <code>triangle</code> 的程序。运行该程序看看它做了什么：</p>
<pre><code>./triangle
</code></pre>
<p>此时应该会输出谢尔宾斯基三角形的 ASCII 表示形式——太酷了！尝试再次运行 <code>make</code>：</p>
<pre><code>$ make
make: Nothing to be done for `all'.
</code></pre>
<p>该输出并不是错误提示，只是意味着程序的源代码没有任何变化，因此不需要重新编译任何内容。</p>
<p>在 VS Code 中打开 <code>triangle.c</code>，将 <code>main</code> 中变量 <code>nlevels</code> 的值从 3 更改为 5。保存文件后，修改会自动同步到服务器。<strong>源码修改后，必须使用 <code>make</code> 重新构建程序</strong>，然后才能运行新构建的程序来显示更大的三角形。如果忘记重新运行 <code>make</code>，将运行修改前的程序！</p>
<p>起始代码使用固定常量来表示要打印的层数。你的任务是扩展程序，提供可选的命令行参数，允许用户指定层数。如果没有参数，<code>./triangle</code> 应默认为 3 层。如果提供参数，例如 <code>./triangle 4</code> 或 <code>./triangle 2</code>，则层数由参数指定。</p>
<p>如果给定的层数不合法（大于 8 或负数），程序应该拒绝绘制图形，并打印一条有用的解释性消息，通知用户如何纠正错误，然后以状态 1 提前终止程序（这表明程序执行出现问题）。实现该任务的最佳函数是 <code>error</code> 函数；查看手册（<a href="https://man7.org/linux/man-pages/man3/error.3.html"><code>man error</code></a>），获取有关此函数的更多信息。需要注意的是，你应该指定 <code>errnum</code> 为 0，因为我们不需要打印出与特定错误代码相对应的错误消息。其余参数的值可以通过文档尝试确定。</p>
<p>你的实现必须和 <code>samples</code> 中的示例程序完全匹配。</p>
<blockquote>
<p>注意：可以假设用户只输入整数值，不必担心处理非整数的参数。如果用户指定多个命令行参数，则应仅使用第一个参数。</p>
</blockquote>
<p>你应该在程序中定义常量，而不是使用“魔法数字”——硬编码到程序中的数字。</p>
<p>为了完成该任务，程序需要将用户的参数（以字符串形式提供）转换为整数。 C 标准库函数 <code>atoi</code> 可以用于执行此操作。查看手册 (<code>man atoi</code>) 或在线文档自行学习该函数。</p>
<blockquote>
<p><strong>man 在线手册操作说明</strong></p>
<p>在命令行输入 <code>man error</code> 后，终端会进入 <code>error</code> 函数的在线手册文档。手册会列出函数名称、引入的头文件、函数原型、以及一些说明描述。</p>
<p>常用快捷键如下：</p>
<ul>
<li><code>j</code> - 向下移动一行</li>
<li><code>k</code> - 向上移动一行</li>
<li><code>ctrl + f</code> - 向下翻一页</li>
<li><code>ctrl + b</code> - 向上翻一页</li>
<li><code>q</code> - 退出</li>
</ul>
<p>参考阅读：</p>
<ul>
<li>https://www.howtoforge.com/linux-man-command/</li>
<li>http://cn.linux.vbird.org/linux_basic/0160startlinux_3.php</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="更新记录"><a class="header" href="#更新记录">更新记录</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>

---
type: lab
date: 2023-12-22T7:30:00+00:00
title: '实验 4. void* and callbak'
tldr: "本次实验带你了解原始内存的世界，了解 C 泛型编程的工具以及常见的问题。"
pdf: https://cs102doc.stickmind.com/topic_4/lab_4/index.html
hide_from_announcments: true
# attachment: /static_files/starter-proj.zip
---

本次实验带你了解原始内存的世界。目标是让你能够写出并使用将函数作为参数的代码（包括一些神秘的语法），并了解如何尽可能地利用类型系统来编写代码，以及在没有类型系统的情况下该如何处理。你应该知道如何正确调用 `memcpy/memmove`，确切地知道在哪里需要类型转换以及为什么需要，并且对二级指针的正确使用提高警惕。

以下一些问题用于检测你的理解，并让你进一步思考这些概念：

- 为什么必须在指针算术表达式中对 `void*` 进行类型转换？
- 当源和目标重叠时 `memcpy` 的行为是什么？ `memmove` 如何正确处理重叠区域？
- *非对称比较函数*是将其两个 `void*` 参数转换为不同的指针类型的函数。为什么将非对称比较函数传递给 `bsearch`？
- C 语言搜索函数找到元素后，通常返回一个指向该元素的指针，而不是元素本身。为什么是这样？

## 学习目标

- 探索 C 语言中的 `void*` 和函数指针如何用于泛型编程
- 学习如何实现泛型函数和用户回调函数
- 调试 `void*` 陷阱

## 初始代码

你的个人用户目录下应该已经有 `cs102` 这个文件夹了，通过下面的命令拷贝初始代码到该目录中：

```Shell
cp -r /home/cs102-shared/labs/lab4 ~/cs102
```

# 探究 memmove

C 标准库提供了一些原始内存（raw memory）相关函数，可以对未指定类型的数据进行内存级别的操作（例如 `memcpy`、`memset` 等）。在文件 `memmove.c` 中包含了一个 `memmove` 的实现，该版本基于 `musl` 的实现代码。一起来研究下函数的实现，以便更好地理解这些函数是如何实现的。

以下一些问题用于检测你的理解，并让你进一步思考这些概念：

- 该函数的接口将其参数声明为 `void*` 指针，但在内部它将这些指针作为 `char*` 进行操作。这里为什么不一致？尝试通过将接口声明为 `char*` 或更改实现为 `void*` 来统一操作，这将产生什么后果？
- 请注意第 11 和 12 行，非类型化指针赋值给类型化指针时，没有强制类型转换。`void*` 是通用指针，可以与其他指针类型自由交换，无需强制转换。话虽如此，关于是否需要强制类型转换的争议问题，网上一直存在着[一场持续不断的讨论](https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc)；这里采用的策略是不作转换，因为这是非必需的。
- 第 14 行在处理什么特殊情况？
- 查看 `memcpy` 和 `memmove` 的 `man` 文档，了解这两个函数之间的差异。第 18 行在处理什么特殊情况？
- 第 22 和 27 行的 `if/else` 区分了哪两种情况？为什么这两种情况都是必要的？
- `memmove` 的 `man` 文档指出，该操作就像复制了两次数据一样（`src->temp`、`temp->dst`），这意味着调用 `memmove` 的时间可能是调用 `memcpy` 的两倍。然而，`musl` 并没有按照文档字面的方式实现。它不仅正确处理了重叠问题，还避免了复制两次的问题。那么它是如何操作的呢？关注下第 24~26 行和第 29-31 行——每个循环中发生了什么？在此实现中，使用 `memmove` 相对于 `memcpy` 的额外成本预期是多少？
- 跟踪调用 `musl_memmove(NULL, "cs102", 0)`，请问尝试读/写无效指针是否会导致段错误？为什么？调用 `musl_memmove(NULL, "cs102", -1)` 的情况又是什么？通过运行 `memmove.c` 程序来验证你的理解。
- 为什么不总是使用 `memmove`？`man` 文档似乎暗示在使用 `memmove` 而不是 `memcpy` 时，某些实现（尽管不是 `musl`）确实会受到性能影响。此外，适当地使用 `memmove` 和 `memcpy` 可以告诉某些代码读取器，数据是否会发生重叠。鉴于此，我们默认使用 `memcpy`，仅在必要时使用 `memmove`。

`memmove` 的实现可能会让你想起 `strncpy` 函数。 `memxxx` 函数与其 `strxxx` 等效函数有很多共同点，特殊情况是没有在零字节处停止。事实上，`memxxx` 函数包含在 `<string.h>` 模块中，并且很可能是由同一作者编写的。

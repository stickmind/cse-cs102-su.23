# GDB 调试技巧

我们会定期尝试向你介绍新的有用的 `gdb` 命令或功能，目的是帮助你进行调试。本次实验，我们介绍“检查”命令，以及如何打印数组。对于每一个命令，尝试设置断点并打印 `gdb_practice.c` 文件中的值，我们已经在其中声明了一些变量。请随意编辑并使用该文件，以便熟悉这些功能。

检查命令 `x`（单击[此处](ftp://ftp.gnu.org/old-gnu/Manuals/gdb/html_chapter/gdb_9.html#SEC56)查看文档）是一个很有用的命令，用于检查内存内容，但与内存中的数据类型无关。它类似于 `print`，但针对的是通用内存而不是特定类型的变量。

例如，你可以使用 `x` 打印给定地址开始的一定数量的字节。例如，如果有一个指针 `ptr`，则可以通过执行 `x/8bx ptr` 打印出从指针记录的位置开始的 8 个字节，其中包含的是十六进制的地址。斜杠后面的可选参数指定你要打印的内容。第一个（例如 `8` 或 `2`）指定要检查的数量，第二个（例如 `b` 或 `w`）指定要打印的单位是字节还是字（一个字为 4 个字节）等，第三个（例如 `x`）指定如何打印它们（例如 `x` 代表十六进制，`d` 代表十进制）。

准备好后，请使用 `gdb_practice` 尝试以下操作：

- 在 `gdb_practice` 程序上运行 `gdb`。在 `main` 上设置断点，并单步执行变量声明/初始化（包括数组 `nums`）之后的函数。
- 尝试 `x/4bx ptr` 以十六进制打印出从 `ptr` 中的地址开始的 4 个字节。你看到了什么？这是为什么？
- 尝试 `x/8bx ptr` 以十六进制打印出从 `ptr` 中的地址开始的 8 个字节。你看到了什么？这是为什么？ （提示：`number2` 和 `number` 的位置有什么关系？）
- 尝试 `x/8bx nums` 以十六进制打印从数组 `nums` 开头开始的 8 个字节。你看到了什么？这是为什么？

如果从栈数组的声明函数中打印栈数组，`gdb` 将显示该数组及其内容。在这种情况下，`gdb` 可以访问元素类型和元素计数，并利用这些信息来打印整个数组的表示。但是，在其他上下文中，它不能自动执行相同的操作，例如堆数组或传递到函数中的数组/指针。

- 在 `main` 函数中尝试使用 `print` 打印 `nums`
- 在 `my_function` 中再次尝试此操作，查看该行为

然而，在这些上下文中打印整个数组是可行的，但你必须向 `gdb` 提供更多信息。让我们看看如何操作：

- 在 `gdb_practice` 程序上运行 `gdb`。在 `main` 上设置断点，并单步执行变量声明/初始化（包括数组 `nums`）之后的函数。
- 尝试 `p num`。在其声明的上下文中，`gdb` 知道它是一个特定大小的栈数组，并且可以显示整个栈数组的内容。很棒！
- 尝试 `p argv`。 `gdb` 对 `argv` 的了解就是它是一个指针。糟糕！
- 尝试 `p argv[0]@argc`，`gdb` 现在将打印 `argv` 数组的全部内容。万岁！
- 要学习的语法是 `p ELEM@COUNT`，其中 `ELEM` 是要打印的**第一个元素**，`COUNT` 是要打印的元素的数量。 `ELEM` 和 `COUNT` 是 C 表达式，可以引用当前作用域中的任何变量。尝试 `p nums[1]@2` 显示数组中间的 2 个元素。
- 尝试在 `my_function` 函数使用此功能来打印传入的数组内容。
- 如果需要，你还可以添加类型转换。例如，给定一个 `void*` 类型的参数 `ptr`，你知道它是 `char*` 类型的 `nelems` 元素数组的基地址，那么你就可以使用 `p *(char**)ptr@nelems` 打印整个数组。


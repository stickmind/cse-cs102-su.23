# 实现 myls

你已经多次使用 `ls` 来查看目录内的文件。现在轮到你来实现这个主力命令行程序的简化版本，这也是一个很好的函数指针练习。

`myls` 程序的运行方式与标准 `ls` 类似，但作了许多简化，也包含一些差异。虽然心理上将 `myls` 看作和标准 `ls` 相同的程序可能会有所帮助，但请不要错误地尝试对比标准 `ls` 的更复杂功能的输出结果。下面的列表列举了 `myls` 所需的功能。如果对 `myls` 的预期行为有疑问，请观察 `samples` 目录中示例程序的行为，而不是与标准 `ls` 进行比较。

- `myls` 可以使用零个或多个目录路径作为参数。它可以列出每个路径的文件内容。如果不带参数调用，`myls` 会打印当前目录 (`.`) 中的文件列表。
- `myls` 仅支持目录路径作为参数。如果参数是某个文件或不存在的路径，它应该打印一条错误消息并跳过该参数。你应该调用 `error` 函数，将错误消息与示例程序进行完全匹配，使用类似的文本“**cannot access __**”，填写无效参数的名称，以及错误代码 `0` 和状态代码 `0`（程序仍然可以继续运行）。
- `myls` 每行只打印一个文件名。
- 除非使用 `-a` 标志调用，否则 `myls` 忽略以 `.` 开头的文件名。
- `myls` 在打印目录内同样是目录的名称时，会添加尾部斜杠。注意，[符号链接](https://zh.wikipedia.org/wiki/%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5)（symbolic link）是一类特殊的文件，不属于目录，可以当作普通文件对待。
- `myls` 默认按名称顺序打印目录中的文件，名称按字典顺序进行比较（即 `strcmp`）。如果使用 `-z` 标志调用，则排序顺序将改为按类型排序（目录在非目录之前）。遇到相同类型的文件，再按名称进行排序。
- `myls` 不支持除 `-a` 和 `-z` 之外的命令行标志
- `myls` 应调用标准 `scandir` 函数，而不是重新实现其功能。鉴于 `scandir` 已经完成了 `ls` 程序的大部分工作，你只需编写过滤/比较函数，对 `scandir` 进行一次调用，然后打印结果列表即可。作为补充，`man scandir` 的文档包含一个简短的示例程序。小提示：该示例程序碰巧以相反的顺序打印条目，这可能不是你想要的。小心不要从文档中直接复制粘贴代码，除非你认真审查过，了解它做了什么并知道如何根据需要进行调整。

> **注意**
>
> 本次作业的一个重要限制是，不允许使用 C 标准库中的 `versionsort` 或 `alphasort` 函数作为回调函数参数。你应该实现自己的比较函数。

文件 `myls.c` 为你提供了少量的代码来处理命令行参数。在开始之前，首先阅读并理解给定的代码，弄清楚如何将其合并到你的实现中，最后为你实现的代码以及初始代码添加注释。初始代码旨在帮助你入门，但你完全可以根据需要随意删除/修改这些代码。

你可以使用 `typedef` 为函数指针类型指定昵称，让代码更简洁。除了可以避免重复原始的语法，还可以更简单地创建该函数指针类型的变量。在文件 `mysort.c` 中也有该用法的示例。

处理命令行参数也是一项繁琐的工作。 GNU 的扩展 `getopt` 在一定程度上，有助于简化这个操作。使用 `man 3 getopt` 了解有关其工作原理的更多信息。使用 `getopt` 时如何检测并报告无效的选项？

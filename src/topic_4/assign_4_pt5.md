# 实现 mysort

对于作业的最后部分，你将实现你自己的 `sort` 命令，称为 `mysort`，它将使用 `binsert` 函数作为底层实现。`sort` 是另一个过滤器命令，类似 `uniq` 和 `tail`，你在上次作业中已经实现了它们的简化版本。标准 `sort` 命令逐行读取输入，然后按指定顺序打印出各行。它支持各种命令行标志控制排序的行为。以下是 `sort` 的使用示例：

```Shell
$ cat samples/colors
red
green
green
red
blue
blue
blue
red

$ sort samples/colors 
blue
blue
blue
green
green
red
red
red

$ sort -u -r samples/colors 
red
green
blue
```

`mysort` 程序的运行方式与标准 `sort` 类似，但有许多简化和一些差异。虽然心理上将 `mysort` 看作和标准 `sort` 相同的程序可能会有所帮助，但请不要错误地尝试对比标准 `sort` 的更复杂功能的输出结果。如果对 `mysort` 的预期行为有疑问，请观察 `samples` 目录中示例程序的行为，而不是与标准 `sort` 进行比较。

以下是 `mysort` 所需的功能：

- `mysort` 读取一个文件：指定文件（由参数指定）或标准输入（参数未指定）。  
- `mysort` 的默认排序顺序是字典顺序（字母顺序）。  
- 如果使用 `-l` 标志调用，则排序顺序是按行的长度递增。  
- 如果使用 `-n` 标志调用，则排序顺序按字符串数值（将 `atoi` 应用于每一行并比较数字）。  
- 如果是重复行，即根据排序规则，比较结果相等的行，则可以按任意顺序输出。  
- 如果使用 `-r` 标志调用，则排序顺序将相反。（提示：对输入进行常规排序，只需更改打印时的顺序即可）  
- 如果使用 `-u` 标志调用，则丢弃重复的行。排序后的输出只包含输入中互不相同的行。根据排序顺序来确定哪些行是重复的（例如，如果按长度排序，则长度相同的两行被视为重复）。  
- `mysort` 的标志可以单独使用或组合使用。如果同时使用 `-l` 和 `-n`，则命令行上最后一个标志将用作排序顺序。  
- 除了 `-l -n -r -u` 之外，`mysort` 不支持其他任何命令行标志。

在底层实现中，`mysort` 应该具有以下行为：

- `mysort` 使用 `fgets` 将一行内容读取到栈数组中。该栈数组的大小应设置为最大大小（参阅 `MAX_LINE_LEN` 常量，预估一个较大的值）。对于超过最大长度的输入行，我们不会对其进行任何测试。你还可以假设所有输入行都以换行符结束，这可以避免在输入的最后一行出现特殊情况。  
- 读取要存储的行后，应将其复制到适当大小的动态堆内存中进行存储。此时，函数 `strdup` 会很方便。
- `mysort` 应该能够处理任意行数的输入。如此大的行数组对于栈内存来说可能太大了，因此这个数组必须是在堆内存上分配的。由于无法提前确定行数，所以 `mysort` 应该将数组分配为一个最小初始数量（请参阅 `MIN_NLINES` 常量），然后每次填满时，将其大小加倍。
- `mysort` 的 `-u` 选项必须重复调用 `binsert` 函数。这里要求对所有重复行仅存储一次，而不是存储所有的行，再将重复的删除。另外，此处不应该调用 `qsort`。 
- 如果在没有 `-u` 标志的情况下执行，`mysort` 应该只调用一次 `qsort` 并且不会调用 `binsert`。

重要提示：在实现过程中，如果你需要存储某一行，则仅应在堆上存储。另外，如果不需要存储该行并在稍后进行打印，则不应在堆上分配内存。如果你的内存使用量明显高于示例程序，则可能是因为这个原因。

这可能看起来与之前的作业相似，你最初可能会倾向于复制粘贴之前的代码，但最终应该意识到此实现中存在着一些显着的差异。与上一个作业不同，本次作业需要**使用不同的策略**来读取未知大小的文本——先将其分配在栈上，然后仅在知道完整大小后才使用堆内存进行分配，因为此时才能准确分配你需要的内存大小来存储数据。

不同的方法各有利弊。对于本次作业，你可能会采取上一份作业使用的方法，由于没有使用栈内存进行预先存储，在堆上分配的空间将略多于所需的大小。而本次作业推荐的策略，将使用大量栈空间来存储初始字符串，最终的结果是你可以精准地分配所需的堆内存大小。我们希望通过这两次作业，能够让你充分练习这两种有效的开发模式。

文件 `mysort.c` 为你提供了少量的代码来处理命令行参数。在开始之前，首先阅读并理解给定的代码，弄清楚如何将其合并到你的实现中，最后为你实现的代码以及初始代码添加注释。初始代码旨在帮助你入门，但你完全可以根据需要随意删除/修改这些代码。

`mysort` 的一个核心目标是**如何在不重复代码或使代码过于复杂的情况下，优雅地处理排序选项的组合**。特别注意，4 个命令行标志都可以独立地打开，总共有 24 种不同组合。如果你考虑不周，最终可能会从每个组合中创建一个不同的情况，以至于多出 16 倍的代码量。相反，如果你能够统一共同的操作，只在个别差异的地方添加代码来处理，那么可以少走很多弯路。你可能需要不断迭代来解决很多细节，但如果用心去做，最终你将会得到一个非常令人满意的结果！加油吧！

最后，强烈建议你阅读：[Engineering a Sort Function](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.14.8162&rep=rep1&type=pdf)。这篇文章是关于 `qsort` 库函数的思想和工程实践的精彩读物。Jon Bentley 和 Doug McIlroy 是前贝尔实验室的两位名人堂成员，他们写的任何东西都值得一读！

> **FAQ** 如何使用 `sanitycheck` 检测较长输出
> 
> 最后一个测试使用一份很长的数字文件进行排序。如果通过测试，则不会打印整个输出，但如果输出不匹配，那么它将打印整个差异信息，这可能很烦人。
> 
> 除了在终端中滚动查看输出结果，一个更方便的技巧是使用管道 `>` 将测试结果保存到一个文件中。需要注意的是，由于输出的格式和颜色问题，文件中可能会显示一些奇怪的字符。解决方法是，可以使用以下命令，使用正确的格式打开文件：`less -R outputfile.txt`。总结一下这些步骤：
> 
> ```Shell
>	$ sanitycheck > outputfile.txt 
>	$ less -R outputfile.txt
> ```



# 作业 4：深入泛型指针

本次作业用于测试你对话题 4 的理解，你将实现 `ls` 和 `sort` 命令的简化版本。你的 `ls` 命令可以使用多种方式打印出目录中的文件列表。你的 `sort` 命令将按序打印文件中的行。

本次作业重点关注包含 `void*` 的泛型编程、函数指针和泛型内存处理，并通过以下几个方面的训练，培养你的技能： 

- 理解 C 语言函数指针的目的并学会使用
- 以用户身份使用 `void*` 泛型接口
- 使用原始内存操作实现 `void*` 泛型函数

完成作业后，你应该能够熟练地掌握内存管理，并能够使用/实现 `void*` 泛型接口。最关键的是能够正确地传递/接收变幻莫测的 `void*` 指针：如何处理一级/多级指针的解引用，需要什么样的类型转换，如何在准确且必要的地方使用 `*` 和 `&`。毫无疑问，你应该知道如何确定解引用的级别，并正确应用它。理解并能够推测出错误的后果也很有必要。

为了帮助你评估学习进度，对于每个作业/实验，我们罗列了一些要点，并提供了一些思考问题。在完成作业后，可以使用这些问题进行自我检查。如果你不能很好地回答这些问题，那么还需要进一步努力。

- 为了读取输入，`mysort` 程序将每一行读入一个临时的栈内存中，该内存大小为最大值，然后将副本复制到大小合适的动态内存中进行持久存储。在类似的案例中，这种栈和堆的配合是一种常见的技术。考虑到栈和堆的特性，解释为什么这种方法是必要的或适当的。
- 函数 `strcmp` 与比较函数 `bsearch` 和 `qsort` 的参数原型大致匹配。粗略的类型转换（例如 `scandir` 所展示的类型转换）可以用来消除编译器的类型不匹配报警，但这却是一个巨大的错误。作为回调函数的比较函数，`strcmp` 几乎从来都不是正确的选择。解释一下为什么。
- 阅读 `lfind` 的 `man` 手册并描述如何使用 `lfind` 配合适当的回调来重新实现 `strlen` 的功能。

### 内存和指针建议

- **栈与堆**。需注意栈分配与堆分配的正确使用以及各自适用的场景。根据一般经验，除非需要动态分配的情况，否则首选栈分配。通常，这两种技术会在程序中一起使用。举个例子，要求动态分配的 C 字符串具有适当的大小，例如字符串“apple”需要 6 个字符的存储空间，不能多也不能少。一个惯用法是分配一个大小为最大值的栈缓冲区来临时存储不确定长度的字符串，一旦确定长度后，再将其复制到大小合适的动态分配的堆缓冲区中。这就是 `mysort` 的行读取代码运行的逻辑。
- **动态调整大小**。 `mysort` 程序事先并不知道输入中的行数，因此它先进行初始分配并根据需要进行增长。大小翻倍是一项经典技术，你会经常看到，例如上次作业中的 `read_line` 缓冲区的处理以及 `musl_scandir` 收集的目录中的文件列表。
- **对分配请求进行防御**。在现代系统上，你不太可能耗尽整个堆，但当堆损坏时也可能返回 `NULL`。无论哪种方式，分配失败都不会带来任何好处，因此最好在情况变得更糟之前停止一切。
- **指针类型应该明确**。如果你知道指针的类型，请务必使用其特定类型来声明。仅当指针类型未知或可能变化时才使用 `void*`。另一方面，声明 `void*` 指针时，也不要指定特定类型。将 `void*` 声明为 `char*` 会误导读者认为该指针是 C 字符串，并可能造成误用，而且编译器不会出现警告。
- **谨慎使用指针运算**。尽管可以通过计算基地址的偏移量来访问普通数组元素或结构体字段，但为了可读性和安全性，你应该使用数组下标和结构体字段名称。尽可能在类型系统中工作，发挥强类型的长处。只有当你只能操作原始内存时，才有必要降级使用低级类型转换和指针运算。
- **优选赋值操作，而不是原始的 `memcpy`**。虽然 `memcpy` 可用于执行任何类型的赋值，但这并不意味着应该始终使用它。考虑以下三种整数赋值的方法：

	```c
	int dst, src;
	void* pDst = &dst;
	void* pSrc = &src;
	
	dst = src;                          // option A
	*(int*)pDst = *(int*)pSrc;          // option B
	memcpy(pDst, pSrc, sizeof(int));    // option C
	```

	三个选项都完成了相同的事情（将 4 字节整数从 `src` 复制到 `dst`）。选项A，普通的赋值语句是直接、干净、安全的。只要你能够在类型系统中工作，这始终是你的最佳选择。如果你被迫通过 `void*` 进行操作，则必须考虑选项 B 和 C。选项 B（使用类型转换进行赋值）是你的第二个选择。该选项可读性好、高效且相对安全（给定正确的类型转换）。选项 C 在最低级别运行，没有任何类型安全保障。指针类型或大小的不匹配都是允许的，这会造成严重的破坏。当尝试读/写 `void*` 的内容时，如果可能，请使用选项 B。仅当你别无选择时，才使用选项 C 的低级内存复制。根据经验：如果 `memcpy` 的 `size` 参数是编译时常量（尤其是使用 `sizeof` 时），则表明你不应该使用 `memcpy/memmove`。仅当在运行时确定要复制的内存类型/数量时，才需要调用原始字节复制。

- **警惕类型转换**。谨慎使用类型转换。你的类型转换破坏了类型系统，并强制编译器毫无怨言地接受它。这种力量伴随着巨大的责任。在使用转换之前，请考虑一下：为什么需要转换？如果不转换会发生什么？有没有更安全的方式来表达我的意图？如何在类型系统内工作而不是忽略它？（即纠正类型不匹配而不是用强制转换来掩盖）。

	你永远不应该转换不变的值（而是修复类型！），转换函数指针也是一个欠考虑的举动（而是修复函数​​原型！）。你也永远不需要将任何内容强制转换为 `void*`，因为它是通用指针，并且与任何指针类型兼容（这样的强制转换是多余的，且可以删除）。当你需要一些类型转换时，要准确地添加它们，并且仅在必须的地方添加它们。如果你的代码重复使用类型转换的表达式，并且不可避免时，请考虑创建一个辅助函数来封装该表达式，以便在任何地方调用，而不是重复代码。

## 初始项目

你的个人用户目录下应该已经有 `cs102` 这个文件夹了，通过下面的命令拷贝初始代码到该目录中：

```shell
cp -r /home/cs102-shared/assignments/assign4 ~/cs102
```

# 回调函数

C 标准库中的通用排序/搜索函数（`qsort`、`bsearch`、`lfind` ...）是可以对任何类型的数据进行排序/搜索的。然而，为了做到这一点，这些接口需要用户提供比较函数，以便让它们知道如何比较两个值。所有这些函数都使用相同形式的标准比较函数：

```c
int comparison_fn_t (const void *, const void *)
```

你实现的任何版本的比较函数，都要接收指向两个待比较值的指针，并返回一个表示比较大小的整数，类似 `strcmp` 的 `+/-/0` 返回值。

要理解的最关键的问题是，所有通用操作都是**通过指向值的指针**来处理数据的，而不是直接处理值。通过地址引用数据是 C 支持泛型函数的基础。发送或接收实际值是不现实的，因为这些值的类型/大小各不相同。相反，交换的是指向值的指针。所有指针，无论指针对象是什么，都是与 `void*` 类型兼容的 8 字节地址。

比较函数的实现遵循以下类似的模式：

1. 将 `void*` 参数转换成已知类型的指针  
2. 解引用类型化的指针以访问该值
   （步骤 1 和 2 通常结合起来，在一个表达式中进行强制转换并解引用）  
3. 比较值以确定要返回的结果

实际的比较逻辑（步骤 3）通常很简单；你必须小心的是步骤 1 和步骤 2 中对 `void*` 的处理，确保不要出错。

查看 `callbacks.c` 文件中的比较函数示例，了解每个函数是如何实现上述模式的。以下是一些需要思考的问题：

- 这些回调函数内部立刻转换 `void*` 参数并存储到类型正确的局部变量中。预先执行此操作，而不是每次使用时再转换并解引用，这样处理有什么优点？
- 向 `qsort` 提供不同的比较函数，允许你使用不同的条件对数组进行排序。例如，对自定义结构体 `city` 进行操作的两个回调函数，分别按不同的字段进行排序。如何编写一个比较函数，实现逆序排序？如何编写一个比较函数，将一个字段作为主要排序顺序进行比较，再通过辅助字段来比较相等的字段？
- 按邮政编码对城市进行排序的比较函数，该实现采用了一种快速的方法来计算正、负或零的比较结果，并返回两个值之间的差异。你明白它是如何运作的吗？这是比较整数值的常见快捷方式。（注意：如果差值超过 `INT_MAX`，减法就会溢出，因此如果需要支持此类极值，请使用 `if/else` 进行判断。）
- 所有比较函数都符合上面列出的原型。这意味着任何比较函数都可以应用于任何类型的数组——不特定于任何类型。使用字符比较函数对 `int` 数组进行排序会产生什么结果？使用字符串比较函数对城市数组进行排序又会怎么样？
- 仔细观察并识别 `compare_letters` 和 `compare_strings` 回调之间的细微差别。可以使用 `compare_letters` 按第一个字母对字符串数组进行排序吗？为什么？
- GNU [libc 文档](https://www.gnu.org/software/libc/manual/html_node/Comparison-Functions.html)给出了一个 `compare_doubles` 比较函数的示例。乍一看，该实现逻辑有点难以理解，所以一起来研究一下。评估类似 `5 > 2` 之类的不等式的结果是什么？尝试在 `gdb` 中确认！在这个案例中，为什么两个不等式相减，可以计算出正确的结果？

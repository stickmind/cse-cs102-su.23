# 探究 scandir

在随后的作业中，你将编写自己版本的 `ls` 命令。为此，你需要以用户的身份使用 `scandir` 库函数，该函数用于为给定的路径创建一个目录列表（包含目录内文件名的一个字符串数组）。它还使用两个函数指针：一个是过滤函数，用于控制列表中包含哪些文件；另一个是比较函数，用于控制列表中文件名的顺序。

对 `scandir` 的理解对于实现 `myls` 至关重要，所以在使用它之前，我们先看看该函数是如何实现的。打开作业代码中的 `scandir.txt` 文件，该实现来自 [`musl`](https://git.musl-libc.org/cgit/musl/tree/src/dirent/scandir.c) 库。这个函数显示出了 C 的内在灵魂：函数指针、动态分配、三级指针，天哪！但是课程进行到此，你对 C 的了解已经足够深入，完全具备能力阅读这样的代码。慢慢来，尝试画图，有不懂的地方就问。

- 查看 `man readdir` 文档，了解 `struct dirent` 的定义。一个奇怪的说明是，最后一个结构字段 `d_name` 是一个字符数组，描述为“未指定大小”。 该数组的大小是自适应的，用于存放指定目录的名称，包括一个终止字符。由此可见，系统默认的文件名称最多支持 255 个字符。
- 破译函数参数的类型。这是粘贴到 [cdecl.org](https://cdecl.org/?q=int+%28musl_scandir%29%28const+char+*%2C+struct+dirent+***%2C+int+%28*%29%28const+struct+dirent+*%29%2Cint+%28*%29%28const+struct+dirent+**%2C+const+struct+dirent+**%29%29) 中的内容。画出 `scandir` 栈帧的内存布局图，包括所有参数和局部变量。跟踪代码时使用该图来查看内存中发生的情况。
- 这个三级指针 `res` 参数相当可怕。这个参数有什么作用呢？为什么需要三级指针？（提示：看一下第 43 行，该行使用了这个参数。那里的代码在做什么？回顾课上讨论的模型，如果主调函数希望通过调用一个函数来修改某个值，那么需要以传地址的方式调用，即指针）。
- 用户在调用这个函数时，如何表明不希望对文件名列表进行过滤？或者不进行排序？
- 变量名 `len` 和 `cnt` 的选择对于表明其用途毫无帮助。变量 `names` 也具有误导性——这是一个字符串数组吗？
- 第 20 行使用了 `continue`，目前为止这可能是你从未见过的 C 结构。它在这里的目的是什么？虽然这个结构并不经常使用，但是当你遇到它时，有必要知道它的作用。
- 过滤器 `sel` 的非零结果是否会导致文件名在列表中保留或丢弃？
- 第 23 行几乎重复了我们在实验 3 的 `calloc` 中查看的一段代码。该测试的目的是什么？删除它会产生什么后果？
- 目录内文件的数量事先是未知的，因此 `scandir` 使用经典的“按需调整大小”分配策略来分配数组。这段代码看起来应该很熟悉，但有一些细节需要仔细检查：
	- 它在第 24 行调用 `realloc`，而没有对 `malloc` 进行初始调用。这样使用为什么也是有效的？（提示：查看 `realloc` 文档，了解如何处理该特殊情况）
	- 它使用表达式 `len * sizeof(*names)` 来计算总字节数。如果名称为 `NULL`，则该表达式似乎间接引用了一个 `NULL` 指针，但请牢记 `sizeof` 表达式不会运行，它只是根据表达式的类型（在编译期）确定该类型的大小而已。
	- 大小表达式可以等效地写为 `len * sizeof(struct dirent *)`。使用 `sizeof(*names)` 而不显式使用类型名有什么好处？
- 在第 24 行，它将 `realloc` 的返回值赋值给 `tmp`，并在 `if` 之后将指针从 `tmp` 拷贝到 `names`。为什么它不直接赋值给 `names`？
- 第 28~30 行创建了 `struct dirent` 的堆副本。由于 `d_name` 字段大小自适应，它会分配大小合适的堆内存并复制内容。
- 第 15 行引入了一个神秘的 `errno`。阅读 `man 3 errno` 的更多信息，了解其目的和功能。第 19 行对 `errno` 做了什么，为什么要引入一个 `old_errno`？如果发生分配失败的情况，`errno` 的值是多少？（提示：阅读 `malloc` 文档的 `NOTES` 部分）
- 第 42 行有点难以理解，它对传递给 `qsort` 的函数指针进行了类型转换。尝试在使用和不使用强制转换的情况下编译代码。如果没有转换的情况下，你会收到什么警告/错误？（转换函数指针是一件欠考虑的事情，通常应该避免，但他们选择在这里使用的原因是可以理解的。）
- `scandir` 过滤器函数接收的参数为 `const struct dirent *`；比较函数接收的参数为 `const struct dirent **`。为什么不一致？
- 跟踪 `malloc/free` 的调用，了解该函数中的内存分配和释放。函数退出后还需要执行哪些释放操作？调用者正确释放该内存的步骤是什么？

完成这一部分是一项重大成就。这段代码中发生了很多事情，你应该为能够剖析如此密集的代码而感到疯狂和自豪！对 `scandir` 的理解对于实现 `myls` 至关重要，接下来接受新的挑战吧。

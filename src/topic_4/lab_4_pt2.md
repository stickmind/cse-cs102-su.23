# 探究 gfind_max

在文件 `generic.c` 中包含了一些写好的代码。其中，`gfind_max` 是我们编写的一个通用函数，根据用户提供的比较函数查找最大的数组元素。查看该函数的实现，先了解下泛型函数是如何实现的。

以下一些问题用于检测你的理解，并让你进一步思考这些概念：

- 第 40 行是一个对通用数组中第 `i` 个位置的惯用访问方式。确保理解该表达式的目的和操作逻辑。类型转换为 `(char*)` 的目的是什么？删除该转换会产生什么后果？
- 网站 [cdecl.org](https://cdecl.org/) 可以将声明从“C 乱码转换成英语”。当试图解开一个难以理解的声明时，这个工具很方便。复制 `compare_function` 的参数声明并粘贴到 `cdecl` 中，看看其英文解释。
- 需要注意的是，通过函数指针实现的回调函数，看起来与普通函数调用几乎相同。如果尝试使用错误数量或类型的参数调用函数指针时，会发生什么情况？尝试编辑 `generic.c`， 修改 `gfind_max` 的参数，删除 `compare_function` 的一个参数，看看会发生什么。
- `gfind_max` 返回一个 `void*`。该指针代表什么？为什么函数返回一个指向值的指针而不是值本身？
- 用户如何使用 `gfind_max` 来查找最小元素而不是最大元素？

然而 `void*` 接口天生的宽松的特性，必然会带来危险的客户体验。滥用泛型函数的方法有很多种，并且编译器通常不会警告你的这些违规行为。让我们进一步探讨这种情况。

文件 `generic.c` 中的 `test_max` 函数对 `gfind_max` 进行了四次调用。第一次调用完全正确，并打印了预期的结果。随后的三个调用中的每个调用，在某种程度上都是不正确的。对于下面的每一个，尝试计算出你认为会打印的内容，然后通过运行程序来验证你的理解是否正确。在 `gdb` 中绘制内存图并跟踪程序的状态，可能对理解程序的行为非常有帮助。

- 不正确的调用 `call #1` 传递了一个用于 `int` 元素数组的 `char` 比较函数。奇怪的是，为什么这样的错误调用没有编译或运行时报错？运行 `Valgrind` 报告有什么帮助吗？在这种情况下 `gfind_max` 的表现如何？
- `call #2` 中的错误是什么？报告的“最大值”从哪里来？注意字节的顺序，我们的服务器采用的是“小端法”表示。
- `call #3` 中的错误是什么？为什么这个调用总是返回指向最后一个元素的指针？

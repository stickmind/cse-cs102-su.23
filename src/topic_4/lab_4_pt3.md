# 探究 bsearch_bug

现在检查文件 `bsearch_bug.c` 中的函数 `test_bsearch`。 `bsearch` 是一个 C 标准库函数，用于搜索数组中的元素。通常，为了使 `bsearch` 能够正常工作，必须使用搜索时使用的相同比较函数对数组进行排序。编写此函数的程序员却无法理解这个机制，他不明白为什么可以使用相同的比较函数。最终，他的实现使用了与排序时不同的比较来进行搜索。他知道这样的实现不太好，但无法找到正确的解决方案。

> 在开始之前，请记住核心原则：所有泛型操作都是通过**指向值的指针**来处理数据的，而不是直接处理值。当你探索这些代码时，请记住这一点。绘制内存图并跟踪正在使用的指针和间接引用的级别。此代码是作业 4 中常见的错误示例，因此现在深入了解它，可以更好地完成作业！

- 按原样编译程序并运行它，可以观察到，尽管比较函数不匹配，但它似乎确实有效。更改代码，使用 `compare_first_characters` 作为排序和搜索的比较函数。运行这个版本时，程序就会崩溃。**代码中的哪个操作会崩溃？为什么**？
- 原作者的解决方法是添加一个不同的比较函数用于搜索。这是一个潜在的危险操作，该比较函数将其两个 `void*` 参数类型转换为不同的指针对象类型。它能够正常“工作”的机制并不周全，并且依赖于 `bsearch` 实现中的一些具体细节，这对于其他通用函数的实现来说可能不正确。**你能看出是什么细节吗**？如果你非常仔细地阅读 `man bsearch` 的文档，你会发现，只根据文档要求来，这个实现细节肯定是正确的（查看文档的第二段），但以这种方式实现，仍然不是一个好主意，有一点拼凑的嫌疑（提示：比较函数的第一个参数代表什么？第二个参数代表什么？）
- 对代码进行正确的修复，使用相同的比较函数 `compare_first_characters` 进行排序和搜索，并使程序正常工作（提示：在调用 `bsearch` 时仔细查看传递给 `bsearch` 的参数值）。

本练习的目的是强调作为用户，在使用 `void*` 接口时保持警惕的必要性。同时也说明在编写代码时，试图通过反复试验并拼凑出一份正确代码，也是徒劳的。

虽然随机排列 `*` `&` 和类型转换可能最终会得到正确的组合，但这种方法对你的理解绝对没有任何帮助。

相反，如果你花点时间在纸上画出操作过程、绘制图表并在 `gdb` 中跟踪执行情况，那么你就会明白在什么样的上下文中使用什么级别的间接引用更合适，并且能够深刻理解其中的原因。加油吧，少年！

# 细胞自动机

细胞自动机用于模拟细胞群落的生命周期，你可以将其视为一维细胞阵列，每个细胞可以是活的（live）也可以是死的（empty）。从初始模式开始，自动机使用一组简单的规则模拟后代细胞的出生和死亡。在这部分作业中，你将使用位和位运算实现细胞自动机，以便尽可能有效地利用内存。

这里将细胞群表示为一个 64 位无符号长整型数，每个位用于表示一维世界中的一个细胞。 `1` 表示单元格处于 live 状态，`0` 表示单元格处于 empty 状态。一个位的邻居是其紧邻的左右两侧单元格。规则集（ruleset）根据当前细胞及其邻居的状态，计算出该细胞在下一代中是活的还是死的。基于这种位向量的表示，读取和更新单个位可以使用位运算来完成。

Daniel Shiffman 的精美著作《代码的本质》对模拟的工作原理进行了精彩的解释。感兴趣可以阅读 [Chapter 7. Cellular Automata](https://natureofcode.com/book/chapter-7-cellular-automata/) 以获取更多背景信息。请注意，这里将使用比这些例子更复杂的细胞群落，但想法是一样的。阅读这些背景信息后，请继续阅读以下文字，以确认你对模拟过程的理解。（注意，上述链接的第 7.3 节也实现了一个自动机程序，但它采用了更重量级的数组/OO 设计。这里采用更简化的位运算来实现。）

如何从当前一代生成下一代？正如上述章节中提到的，一个单元格及其两个邻居形成了一个“邻域”。一个邻域实际上是 3 个位组成的数字，值的范围从 0 到 7。考虑一个活的单元，其左邻居是活的而右邻居是死的，二进制邻域表示为 `110`，即 3 个位表示的数字 `6`。那么该单元的下一代是活的还是死的，由规则集位置 `6` 的配置决定。规则集是一个 8 位的数字，每个位表示一个邻域的配置。假设规则集是 `77`，用二进制表示为 `01001101`。以最低有效位表示位置 0，则位置 6 的配置是 `1`，也就是说，这个单元的下一代是活的。

程序 `automata` 演示了一个基本的细胞自动机，根据指定的规则集，从初始状态开始进行多次迭代。如果下一代的状态不再改变，迭代就会提前终止。在下述输出中，每行代表一代，从顶部的第一代到底部的最后一代。下面显示了规则集 `77` 的程序运行示例：

```Shell
$ ./automata 77
                               +                                
++++++++++++++++++++++++++++++ + +++++++++++++++++++++++++++++++
+                            + + +                             +
+ ++++++++++++++++++++++++++ + + + +++++++++++++++++++++++++++ +
+ +                        + + + + +                         + +
+ + ++++++++++++++++++++++ + + + + + +++++++++++++++++++++++ + +
+ + +                    + + + + + + +                     + + +
+ + + ++++++++++++++++++ + + + + + + + +++++++++++++++++++ + + +
+ + + +                + + + + + + + + +                 + + + +
+ + + + ++++++++++++++ + + + + + + + + + +++++++++++++++ + + + +
+ + + + +            + + + + + + + + + + +             + + + + +
+ + + + + ++++++++++ + + + + + + + + + + + +++++++++++ + + + + +
+ + + + + +        + + + + + + + + + + + + +         + + + + + +
+ + + + + + ++++++ + + + + + + + + + + + + + +++++++ + + + + + +
+ + + + + + +    + + + + + + + + + + + + + + +     + + + + + + +
+ + + + + + + ++ + + + + + + + + + + + + + + + +++ + + + + + + +
+ + + + + + + ++ + + + + + + + + + + + + + + + + + + + + + + + +
```

很酷吧？由于规则集是一个 8 位数字，这意味着细胞的演化将有 256 个不同的可能。可以尝试探索一些不同的值，看看有哪些非常酷的输出结果！

你的任务是为程序 `automata` 实现这些函数：

```C
void draw_generation(unsigned long gen);
unsigned long advance(unsigned long gen, unsigned char ruleset);
```

函数 `draw_generation` 输出一个 64 字符组成的行，一个字符表示一个单元格。活细胞显示为 `+`（或者改为预定义的常量，参见作业代码），死细胞显示为空白。每一代的状态都是排好序的，与最高有效位（MSB）对应的单元位于最左列，而最低有效位（LSB）位于最右列中。**建议优先实现这个函数**。完成后，如果你运行该程序，它应该为第一代打印出一行，为下一代打印一个空行（这是由下面的 `advance` 函数初始代码返回的内容），接着它将停止迭代，因为后续状态没有改变。

函数 `advance` 会执行一次迭代，从当前一代生成下一代。对于每个细胞，该函数检查其邻域并根据规则集来确定下一代细胞的状态。**外侧边缘的两个单元，由于只有一个邻居，需要特殊处理；不存在的邻居应该被视为死亡状态**。

建议使用 `sanitycheck` 比较你的输出与示例程序的输出，而不是手动检查。为了便于识别，`sanitycheck` 会将活细胞显示为 `*`，将空细胞显示为 `.`。测试程序时，尝试使用不同的规则集。

你能找到产生谢尔宾斯基三角形的规则集吗？倒置的谢尔宾斯基三角形的规则集是什么？你最喜欢哪个规则集产生的输出？将这些规则集补充到 `custom_tests`，完善测试用例。



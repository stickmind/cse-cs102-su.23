# 中点计算

对于本练习，首先阅读 Google 研究员 Joshua Bloch 的有关整数溢出常见错误的[博客](https://blog.research.google/2006/06/extra-extra-read-all-about-it-nearly.html)。仅仅计算中点这么简单的任务也可能隐藏危险！

我们需要一个能够安全、正确地计算两个整数中点的函数。如果中点不是精确的整数值，不必在意结果如何舍入，只要返回相邻的数就好。

文件 `mid.c` 包含四种不同的计算公式，用于测试简单程序中计算中点的任务。

函数 `midpoint_original` 大部分情况下都能工作，但出现了 Bloch 文章中指出的错误。如果 `x + y` 之和溢出，则结果错误。例如，调用 `midpoint_original(INT_MAX-2, INT_MAX)` 应返回 `INT_MAX-1`，但实际上返回 `-2`。在最初的程序中，该函数是用于计算两个数组索引的中点，这也就解释了为什么这个错误能够潜伏这么长时间而没有被发现（一般的数组很少有这么大的维度）。

Bloch 的文章提出了一些计算中点的修复方案。首先，他提供了 `midpoint_A`，然后提供了 `midpoint_B` 作为更快的替代方案。思考下 `midpoint_A` 和 `midpoint_B` 是如何修复上述问题的。`midpoint_A` 做了什么来避免溢出？`midpoint_B` 又做了什么？

只要两个输入均为非负，`midpoint_A` 和 `midpoint_B` 都可以正常工作。这个约束实际上从未被声明过，它只是隐含在原代码的上下文中，即输入是数组索引。如果输入有一个或两个为负值，那将发生什么问题呢？我们来调查一下！

- 在输入为负数时，`midpoint_A` 容易受到与原始值不同的溢出影响，本例是在减法过程中发生的。产生溢出时，相减的两个操作数必须满足什么条件？减法运算溢出的结果是什么？找出一个你认为可能导致 `midpoint_A` 失败的输入，然后通过编辑 `mid.c` 程序测试你的输入。
- 在输入为负数时，`midpoint_B` 不太容易发生错误。为了暴露 `midpoint_B` 中的问题，我们可以尝试逆向思考。思考一下，可以发现 `midpoint_B` 中的表达式永远不会得出负数——为什么呢？根据这一发现，任何中点为负的输入都会在 `midpoint_B` 上失败。找出一个此类输入并判断将返回什么值？编辑 `mid.c` 程序测试你的输入。

   如果在右移之前将总和转换回带符号的值，则可以解决这个问题，但代价是其他情况又可能失败。编辑代码验证下这个解决思路。似乎我们没法做到两全！

计算中点的最终版本是 `midpoint_C`，这段钻石般的代码来自非凡的 Don Knuth，并真正地解决了所有溢出问题！该函数的工作原理乍一看并不明显，但通过仔细研究，你可以了解它们是如何组合在一起的。

- 首先考虑数字的按位表示以及对应于数字的二进制多项式。例如，`0000...01011`（即十进制数字 11）可以写为 \\(1 * 2^0 + 1 * 2^1 + 0 * 2^2 + 1 * 2^3 = 11\\)。   
- 现在比较 `x` 和 `y` 中不同幂次的项。按位 `&` 找出两个输入相同幂的项，按位 `^` 找出不同幂的项。
- 如何将上述两个结果结合起来，以便找出中点二进制多项式的项？
- 代码中使用 `+` 连接，为什么必须使用 `+`？尝试替换为 `|`，测试运行并思考这两个运算符的区别。

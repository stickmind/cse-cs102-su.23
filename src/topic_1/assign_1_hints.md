# 作业 1 解读

<div class="toc"></div>

在开始作业之前，一定要先阅读初始代码。可以在每个部分前面添加相应的注释，解释清楚该部分的功能即可。遇到理解不了的语法或函数，记得查阅第三方手册或群里求助。只有理解了程序的执行逻辑，我们才能更快更好地写出剩余的代码。

> 阅读代码同样也是学习的过程，学习别人是如何写的，借鉴到自己的代码中。取长补短，才能不断进步。

主函数对于命令参数个数的检查以及 `error` 函数的使用，前一份作业已经练习过。

作业首先引入一个新的接口函数 `strtol` 替代之前用过的 `atoi`。
使用上，`strtol` 更为复杂，需要提供三个参数，但好处是其功能更为健壮，能够提供一些格式上的检查。

```c
#include <stdlib.h>

long strtol(const char *nptr, char **endptr, int base);
```

`strtol` 的 `base` 范围只能是 `[2, 36]` 和一个特殊值 `0`。
  - 如果是 `0` 的话，那么字符串必须符合相应进制的字面量格式（self-indicating）；
  - 如果是其他值，那么字符串必须满足该进制的格式要求（specified）。

函数调用结束后，`endptr` 会指向第一个非法字符处。
  - 如果字符串首个字符就是非法的，那么 `endptr` 指向 `nptr` 首地址
  - 如果字符串整个都是合法的，那么 `endptr` 指向终止字符，即 `endptr` 所指的字节内容是 `\0`

如果输入数值超过 `long` 可以表示的范围，那么只返回 `limits.h` 限定的极值。
  - 此时函数还会把 `errno` 设置为 `ERANGE`

> **注意**
>
> 虽然文档说 `endptr` 不为 `NULL` 时才会记录首个非法字符，但是实际情况，即使 `endptr` 初始化为 `NULL`，函数依然会将 `endptr` 指向首个非法字符。
> 
>在线手册比较陈旧，很多表述并没有清楚地解释当下 C 标准库的实现。结合相关问题，可以自行编写代码测试，看看哪些依然保留，哪些已经改变。

## 饱和计算

### Milestone 1

通过观察示例程序的位模式，可以很容易想出 `signed_max` 和 `signed_min` 位模式的构造方式。通过合理的位运算，以及 `max` 和 `min` 之间的关系，这两个函数的实现应该不难。

```Shell
$ samples/sat_soln 4
4-bit signed integer range
min: -8   0xfffffffffffffff8
max:  7   0x0000000000000007
$ samples/sat_soln 8
8-bit signed integer range
min: -128   0xffffffffffffff80
max:  127   0x000000000000007f
```

这里推荐先实现 `signed_min` 然后再实现 `signed_max`。

> 思考：`MIN` 等于 `MAX + 1` 嘛？

### Milestone 2

第三个函数 `sat_add` 在作业说明中有个线索，可以单独处理溢出或非溢出的情况。

- 溢出时，两个操作数符号相同，而结果符号相反，需要单独处理返回值
- 无溢出时，永远不会出现上述情况，直接返回相加结果

根据以上规律合理使用位操作，只需要检测符号位的情况，就可以实现 `sat_add` 函数。

最后注意作业要求，禁止使用 `< >` 操作符。

## 细胞自动机

### Milestone 1

仔细阅读推荐材料和作业说明，要先理解进化规则和进化过程，能够在草稿纸上手动画出某个简单的规则进化过程。

### Milestone 2

函数 `draw_generation` 是整型位模式转换输出问题。我们可以依次查询每个位的状态，根据状态输出对应的字符串。

> 思考：如何构造合理又全面的测试案例？

### Milestone 3

函数 `advance` 需要分别处理每个位（细胞）及其左右两个邻居，很明显我们需要一个循环操作。

1. 每次循环需要依次向某个方向操作 3 个位

   可以参考课上 `colorwheel` 的思路，依次过滤出需要操作的部分。
1. 然后根据 3 个位的值和规则，计算下一个状态。
2. 最后根据状态，设置返回值变量相关的位。

对于测试部分，我们可以根据作业 0 中谢尔宾斯三角形的输出，反推出规则集。

## UTF-8

### Milestone 1

首先需要判断 `code_point` 的范围，以便确认所需字节数。 除了逻辑操作，我们也可以利用位操作来协助判断范围大小。

这里允许使用比较操作符！但是位操作能实现同样的效果嘛？

### Milestone 2

确认了字节数，那么就可以根据位掩码合理筛选所需部分，依次存入相应的数组中。该部分整体比较繁琐，但熟练掌握 Bitmask 的几种操作，实现这个函数应该没有太大问题。

最后还是要强调测试一定要全面，特别是边界情况。

# 饱和计算

程序 `sat` 执行合成的饱和加法运算，饱和加法将结果限制在可表示的范围内。与补码加法“超范围即溢出”的行为不同，饱和加法在出现正溢出时返回该类型的最大值，在出现负溢出时返回最小值。饱和计算函数在图形学和数字信号处理应用中非常常见。

以下是 `sat` 程序的两个示例。第一个示例打印出 8 位有符号整数的取值范围是 \\([-128, 127]\\)。第二个示例尝试将 126 加到 5，结果会溢出并保持在最大值 127。

```Shell
$ ./sat 8
8-bit signed integer range
min: -128   0xffffffffffffff80
max:  127   0x000000000000007f
$ ./sat 8 126 5
126 + 5 = 127
```

你的任务是编写以下函数，来实现 `sat` 程序的饱和加法。

```C
long signed_min(int bitwidth);
long signed_max(int bitwidth);
long sat_add(long operand1, long operand2, int bitwidth);
```

参数 `bitwidth` 是 4 到 64 之间的数字。以位宽 `bitwidth` 表示的二进制补码有符号整数将被限制在固定范围内。函数 `signed_min` 和 `signed_max` 返回该范围的最小值和最大值。函数 `sat_add` 实现饱和加法运算，如果结果在范围内，则返回其操作数的总和；如果结果溢出，则根据情况返回最小/最大值。虽然此处两个操作数的类型为 `long`，但你可以假设操作数的值始终位于位宽 `bitwidth` 表示的有符号整数的范围内。话虽如此，但这么处理也意味着以位宽 `bitwidth` 表示的值的位数，实际上可能多于所需的位数。所以，这些额外的位需要进行合适的处理，以确保该值在 `long` 范围内能够进行正确的计算。

在编写 `sat.c` 的代码时，有三个重要的限制需要注意：

- **不可以使用关系运算符或 `math.h` 中的函数**。禁止使用关系运算符意味着，你的代码不可以出现 `< > <= >=` 这些比较操作，但你可以使用 `!= ==` 进行相等性检查。你也不应该调用 `math.h` 库中的任何函数，例如 `pow`、`exp2` 等。这些限制旨在引导你使用纯粹的位操作来实现代码。对于其他运算符，例如算术运算符、逻辑运算符、按位运算符……这里不作限制。
- **参数 `bitwidth` 没有特殊情况**。无论位宽 `bitwidth` 的值是 4、64 还是介于两者之间的任何值，你的函数都必须使用一个统一的代码来处理。不可以对某些位宽的值进行特殊处理，比如使用 `if switch ?:` 根据位宽的值将代码分为不同的情况。但是，这并不意味着不能使用条件逻辑，例如单独处理溢出或非溢出的情况。
- **不要使用循环或递归**。此程序根本不需要循环或递归。

违反以上任何一个限制的代码都是不合格的，因此，请仔细检查你的实现是否合规！

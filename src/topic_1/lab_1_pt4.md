# 工作流练习

现在轮到你自己编写一些位运算代码并练习使用 Unix/Linux 开发工具了！

程序 `parity` 输出其命令行参数的奇偶校验。如果值的位模式中存在奇数个 `1`，则该值为奇校验；否则，为偶校验。通过运行 `samples/parity_soln` 程序测试不同的参数，来确认你对奇偶校验的理解。

假设 `parity.c` 中的代码是你的同事编写的，他声称它是“完整的”，但在出门的路上，他们发现了一些未修复的错误。你的任务是使用 `sanitycheck` 和 `gdb` 调试器测试并调试该程序，使其真正的完整。

关于 GDB，[CS107 GDB and Debugging](https://web.stanford.edu/class/archive/cs/cs107/cs107.1206/resources/gdb) 是一个很好的参考。

- 使用 `make` 构建程序并尝试使用不同的值运行 `./parity` 几次。呃哦！似乎它认为每个值都是奇校验！有没有测试出哪些值具有偶校验？​  
- 在调试器下运行 `gdb parity`。可以使用 `list` 命令打印出 GDB 正在检查的部分代码。使用 `list compute_parity` 打印 `compute_parity` 函数并记下更新循环内结果的行号。
- 接下来，在该行上设置一个断点，以便在 GDB 中运行程序时，可以在执行该行之前暂停并等待进一步的指令。可以通过键入 `break XXX` 来添加断点，其中 `XXX` 是函数名称或行号。
- 在 `gdb` 下运行程序，输入 `run`，然后输入命令行参数（用于检查的数字）。 GDB 将运行程序并在断点处暂停。请注意，断点所在的行并没有执行。当停在断点处时，打印 `result` 的值，可以使用 `p result`（命令 `print` 的缩写）进行打印。咦？`result` 似乎包含了一个垃圾值。它竟然从未初始化过！这合法吗？在 Java 等具有安全意识的语言中，编译器可能会防止这种情况发生。
- 执行 `make clean` 并 `make` 检查下有没有构建警告，此处你应该看不到 `gcc` 的任何提醒。在运行时，该变量将使用其内存中剩余的任何垃圾值。这给了我们一个经验教训——在自由放任的 C 语言世界中，你需要提高自己的警惕性。
- 修复该程序、构建并重新运行。参考作业 0 中 `sanitycheck` 的使用，确保你的代码可以通过所有的默认测试。

既然更正后的程序通过了 `sanitycheck` 检查，那么就可以结束了，对吧？没那么简单~请记住，`sanitycheck` 检查的是否彻底取决于其测试用例。默认的测试用例仅仅是一个开始；你可以使用 `custom_tests` 添加自己的测试，以便更全面地验证该程序。

- 仔细阅读 `sanitycheck` 默认的检查结果。它包括多少个不同的测试用例？这些测试用例是什么？​
- 使用 `custom_tests` 中的附加测试进一步检查该程序。可以发现其中一项测试由于超时而失败，但这并不是说该程序效率较低，而是发生了无限循环（死循环）。
- 调试无限循环的最佳方法是在 GDB 下运行程序，一旦停止，使用 `Control-C` 停止程序。 GDB 将显示程序停止时正在执行的位置，可以方便地查看具体发生了什么。
- 一起试一试：在 GDB 中以负参数运行 `parity` 程序并让它停止响应。输入 `Control-C` 中断程序，并使用 `backtrace` 命令查看程序正在执行的位置——此时将显示当前的调用栈，可以查看当前正在执行函数。
- 在循环中步进执行 `step` 并收集信息，以便诊断循环未正确退出的原因。
- 一旦你查出问题的原因，就可以编辑代码来修复它。重新构建并测试，直到所有的错误都被消除为止。

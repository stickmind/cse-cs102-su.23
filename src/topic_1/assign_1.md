# 作业 1. 有趣的位

本次作业要求你完成三个程序，每个程序探索位运算或数字操作的某个特定方面。需要你编写的代码很短，但这些代码片段却非常强大！

这次作业用于测试你对第一个话题的理解。通过以下几个方面的训练，培养你的技能：

- 利用远程 Linux 开发环境，编辑、编译、测试并调试 C 程序​  
- 使用 C 位运算符和算术运算符编写操作位和整数的代码​  
- 在整数表示的限制下编写代码

为了帮助你评估学习进度，对于每个作业/实验，我们罗列了一些要点，并提供了一些思考问题。在完成作业后，可以使用这些问题进行自我检查。如果你不能很好地回答这些问题，那么还需要进一步努力。

- 绝对值是 2 的幂的所有负整数（-8、-32 等）的位模式有什么共同点？
- 如何确定整数位模式是否具有一对连续的“on”位？（使用循环将很简单，但也有一个巧妙的单一表达式……）
- 斯坦福大学计算机科学博士 Sean Anderson 有一个位魔法宝库 [Bit Twiddling Hacks](http://graphics.stanford.edu/~seander/bithacks.html)，推荐收藏。

## 初始项目

你的个人用户目录下应该已经有 `cs102` 这个文件夹了，通过下面的命令拷贝初始代码到该目录中：

```
cp -r /home/cs102-shared/assignments/assign1 ~/cs102
```

## 阅读并注释

作业初始代码作为一个起点，你的首要任务应该是仔细阅读它。你要先弄清楚代码是如何运行的，以及它已经处理了哪些任务。基于这些代码框架，你可以规划如何开发自己的程序。每个程序大约有 25 行，需要你添加的代码可能只有十几行，因此需要你阅读的初始代码比你添加的新代码要多得多。

为了帮助你更好地上手作业任务开发，我们为每个程序提供了一些现成的代码，有些用于处理命令行参数，有些用于处理程序调用时的用户错误，还有一些比较重要的细节，特别是将字符串参数转换为数字。

作业 0 中的 `triangle` 程序使用了 `atoi` 函数，该函数使用起来相对简单一些，但却无法检测格式错误的输入。对于本次作业的这些程序，我们使用更强大但却更复杂的 `strtol` 函数。阅读 `man strtol` 中的函数文档并查看该函数在 `convert_arg` 中的使用方式。

下面一些问题可以用于自测：

- 在缺少参数的情况下调用 `samples` 中的示例程序，程序将如何响应？如果参数过多又将如何？
- ​如何使用 `error` 函数？
- 将用户的字符串参数转换为数字时，传递给 `strtol` 的基数是什么？这允许用户指定哪些基数的参数？另外，如何根据用户参数确定基数？
- 如果 `strtol` 在要转换的字符串中遇到无效字符，它会做什么？
- `strtol` 的第二个参数如何用于错误检测？为什么 `end` 变量不用初始化也可以使用呢？如果不希望进行错误检测，你会传递什么作为第二个参数？
- 如果要求转换的值太大而无法用 `long` 表示，`strtol` 会做什么？

阅读完代码后，尝试进行一些实验！构建并运行程序，使用不同的参数调用它们，看看每个程序是如何处理的。也可以在调试器下运行程序，逐步执行每行代码，并随时打印中间值。通过观察代码的运行情况，可以更好地理解代码。如果你能很好地回答上述自测问题，那么对初始代码的理解就够了，开始接下来的任务吧。

## 其他建议

为了帮助你完成这次作业，我们整理了一些技巧，可以帮助你解决很多问题以及一些常见的位运算。

**拥抱十六进制**。十六进制可以非常方便地与二进制进行转换。每个字节都用两个十六进制数字表示，一个表示 4 个高位，另一个表示 4 个低位。十六进制掩码或通过其构造的掩码，可以更好地映射到二进制表示形式，并减少编码错误。例如，从 32 位值中提取符号位的掩码可以清晰地表示为 `1 << 31` 或 `0x80000000`，并且两者的可读性都非常好。该掩码也恰好是十进制的 `2147483648U`，但谁能一眼看出来呢？如果不小心输错了，比如 `2147486348U`，你能注意到吗？所以，不要使用十进制，优选十六进制！

**学习位运算**。调用 `pow` 函数来计算 2 的整数幂是一种浪费。使用 `1 << 10` 可以完美地计算 `pow(2, 10)`，并且需要更少的计算周期。位运算也是重排/隔离/更改位的正确工具，而不是间接地使用包含 2 的幂的整数乘法/除法/取模。

**力求直接明了**。可能有更直接的方法来编写某些位运算。以下是一些示例：

*不要左移右移*。在下面的代码中，第一个版本先右移然后立即左移，这个操作似乎只是将位模式循环回到原来的位置，但实际上右移将丢弃 `lsb`，然后左移将填零。这是擦除 `lsb` 的迂回方法，而更好的方法是直接将其屏蔽，如第二个版本所示：

```c
result = (val >> 1) << 1;     // original version

// Better version:
result = val & ~1;            // better: directly turn off lsb
```

*不要有多余/不必要的操作*。想象一下，你的目标是提取一个字节的 4 个高位，并将它们下移到低半字节。你可以通过两个步骤（掩码和移位）来完成此操作，但实际上，移位已经丢弃低位了，因此无需掩码操作！

```c
result = (val & 0xf0) >> 4;   // mask off lower 4, then shift down

result = val >> 4;            // better: directly shift, 
                              // low-order bits gone!
```

*不要掉进复杂的陷阱*。当构造组合的位运算时，先考虑是否有更直接的方法来完成同样的事情，例如：

```c
b = a | 0                     // this is no op!
b = a ^ -1                    // more clearly written as b = ~a
b = ~a + 1                    // more clearly written as b = -a
b = (1U << 31) - 1            // INT_MAX from <limits.h> 
b = INT_MIN >> 31             // This is -1!
```

起初，你可能会发现需要使用更长的表达式，但是仔细思考，你会发现还有更简洁的写法。最终的目标是避免将问题复杂化。

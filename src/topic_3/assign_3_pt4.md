# 实现 myuniq

标准 `uniq` 是一个过滤器，处理提供的输入，删除相邻的重复行，然后输出。当使用 `-c` 标志调用 `uniq` 时，它会计算每行出现的次数。以下是 `uniq -c` 的使用示例：

```Shell
$ cat samples/colors
red
green
green
yellow
blue
blue
blue
blue
$ uniq -c samples/colors 
    1 red
    2 green
    1 yellow
    4 blue
```

你要编写的 `myuniq` 程序在操作上与标准 `uniq` 类似，但有一些差异：

- `myuniq` 过滤掉所有重复行，无论它们出现在输入中的何处（标准 `uniq` 仅检测输入中彼此相邻的重复行）
- 每个重复行仅打印一次，打印顺序与输入中出现的顺序相同。
- `myuniq` 总是在输出的每一行前面加上前缀，表示该行在输入中出现次数的（这是使用 `-c` 标志调用标准 `uniq` 的行为）  
- `myuniq` 不支持任何命令行标志（标准 `uniq` 有许多标志）

为了检测输入中任意位置的重复行，`myuniq` 必须跟踪输入过程中看到的所有行。它还需要计算每行重复的次数。定义一个结构体数组，可以存储这些信息，帮助我们完成这项工作，但我们仍有一个难题。这个数组需要多少个条目？与 `mytail` 提前确定数组的分配大小不同，`myuniq` 的数组大小是不确定的。它可能需要一个包含 `10` 个条目的数组，或 `10,0000` 个条目的数组。如果尝试选择一个固定值，对于某些输入来说可能太大，而对于另一些输入来说则太小。听起来，似乎按需分配才是最合理的！

我们对 `myuniq` 要求是，先为数组分配 `100` 个条目作为初始大小，如果该数组填满时，调整数组大小用于添加另外 `100` 个条目。然后根据需要重复此操作，每次添加额外的 `100` 个条目。（注意这里的策略不是翻倍）

为了匹配示例程序的输出格式，在打印行的计数时，你应该使用 `printf` 标记 `%7d` 而不仅仅是 `%d`。这将打印宽度为 `7` 的数字，输出将类似于：

```
      1 red
   5000 blue
  12413 green
1253473 yellow
```

`myuniq` 程序中的大部分挑战都与能否正确处理内存有关。当完成本次作业时，你将成为堆内存管理大师！

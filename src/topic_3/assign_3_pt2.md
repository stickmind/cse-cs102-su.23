# 实现 read_line

程序 `mycat`、`mytail` 和 `myuniq` 依赖于文件读取操作。文件读取的工作原理大都类似，但在不同语言中具有不同的语法。你的第一个任务是研究作业初始代码以及 [C 标准库指南](https://web.stanford.edu/class/archive/cs/cs107/cs107.1206/guide/stdlib.html)，大致了解 C 语言文件读取的工作原理。我们为你提供了完整的测试程序 `mycat.c`。而 `myuniq.c` 和 `mytail.c` 的起始文件包含处理命令行参数和文件设置的代码，其余部分将由你来实现。你应该先阅读并理解给定的代码，弄清楚如何更改并扩展它以满足你的需求，最后记得添加注释来记录你的实现策略。

查看初始代码时，有一些需要考虑的问题：  
  
- `fopen` 的 `mode` 参数有哪些可能的选项？如果你尝试打开一个不存在的或没有权限的文件，会发生什么情况？  
- 未能正确关闭文件的后果是什么？  
- 当没有文件名参数时，程序如何切换到标准输入进行读取？  
- 从文件读取的操作是否也可以用于从标准输入读取，还是说这两种操作需要不同的代码？  
- 程序 `mycat` 的默认行为对应于调用标准 `cat` 时，使用哪个命令行标志？  
- `mytail` 支持命令行参数 `-number` 来控制打印的行数。初始代码如何处理该可选参数？  
- `mytail -number` 的参数范围是什么？  

与往常一样，我们提供的代码已删除了注释，你的工作就是提供 `mytail.c`、`myuniq.c` 和 `util.c` 文件中缺少的文档。可以不用注释 `mycat.c` 文件。

## 实现 `read_line`

标准库函数 `fgets` 用于从文件中读取文本。

```c
char* fgets(char* buf, int bufsize, FILE* stream);
```

与大多数库函数一样，`fgets` 不进行任何分配，而是由用户提供缓冲区用于写入。用户必须根据预期的大小预先分配“足够大的”内存来存储该行。如果用户提供的内存太小，则函数可能会发生缓冲区溢出（如果使用 `gets`）或截断读取操作（如果使用 `fgets`）。

一个对用户更友好的设计是由读取函数在内部处理内存分配并创建适当大小的行。你将实现一个以这种方式运行的 `read_line` 函数：

```c
char* read_line(FILE* fp);
```

函数 `read_line` 从文件中读取下一行。返回值是一个动态分配的且以空字符结尾的字符串（如果读到 `EOF`，即“文件结尾”，则返回 `NULL`）。此函数的执行方式是类似于 `fgets` 的更时尚的版本（事实上，你应该使用 `fgets` 来实现它！），因为它不仅可以读取下一行，还可以为字符串分配内存，这将使用户的工作变得更轻松。

以下是该函数操作的一些具体细节：

- 该函数应该从文件中读取下一行。所谓“一行”，就是遇到第一个换行符或 `EOF`（以先到者为准），然后结束读取。
- 返回的字符串应该包含换行符前的所有字符，但不应包括换行符本身。如果下一行仅包含换行符，则返回空字符串。
- 如果 `read_line` 到达 `EOF`，意味着没有更多字符可以读取，则该函数应返回 `NULL`。请注意，需要先调用 `fgets`，然后才能检查 `EOF` 条件，因为尝试读取超出文件末尾的过程会触发 `EOF` 条件。这种情况应该清理所有预先分配的不再需要的内存，并返回 `NULL`。
- 如果调用 `fgets` 时发生错误，该函数应该返回该时刻已读取的所有内容，如果没有读取任何内容，则返回 `NULL`（提示：即便你没有考虑到这种情况，你的函数最终可能仍然能够按此逻辑执行）。在这种情况下，你可以假设如果在调用 `fgets` 期间发生错误，则该时刻不会读取任何字符。
- 要为返回的字符串分配内存，该函数应该先进行初始分配，并在需要时对其扩容。更具体地说，函数应该首先 `malloc` 一个最小的缓冲区（32 字节），第一次调用 `fgets` 时，先将行的前一部分读入缓冲区。如果还有更多内容需要读取，函数应该重新分配缓冲区，并将当前大小翻倍（64 字节），并再次调用 `fgets` 读取该行的剩余部分。重复这样的过程，翻倍扩容并写入内容，直到最终到达该行的换行符或 `EOF`，此时表明一行读取完毕。
- 如果无法分配足够的内存，`read_line` 应该触发致命断言。养成一种好习惯，你应该为每次分配请求的结果添加断言 `assert`。分配失败的情况虽然很少见，但却是致命的。
- `read_line` 应该返回动态分配的内存块的地址，该位置存储下一行的内容。不再需要时，用户负责释放该内存。
- 你应该只需要使用 `fgets` 文件 I/O 函数，不需要使用任何其他函数，例如 `feof`、`fgetc` 等。

在 `util.c` 文件中编写 `read_line` 的实现。你可以使用我们提供的 `mycat.c` 程序对其进行测试。 `mycat` 程序与 `sanitycheck` 集成。稍后你将使用 `read_line` 函数继续编写 `mytail` 和 `myuniq` 程序。

注意：你可以假设正在读取的不是二进制可执行文件。可执行文件可能包含“空字节”，或全零字节。在处理字符串时，这些可能被当作空字符 `NUL` 来处理，从而让实现更棘手，所以你不必担心这一点。

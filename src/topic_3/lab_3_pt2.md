# Valgrind 检测内存错误

上个实验介绍了 Valgrind。随着我们不断编写大量使用指针和动态内存的 C 代码，这个工具将变得越来越重要。特别是，Valgrind 非常擅长检测与动态内存相关的内存问题，例如越界写入已分配的内存、访问已释放的内存、重复释放内存等。程序 `buggy.c` 植入了一些堆内存使用上的错误，可以看看 Valgrind 是如何处理和报告这些错误的。

- 查看 `buggy.c` 中的程序并考虑 `error #1`。当执行 `./buggy 1 argument` 调用时，程序将把 `argument` 复制到堆分配的 8 个字符的空间中。如果参数太长，写入内存时，数据将超出分配空间的末尾——即“缓冲区溢出”。类似之前的字符串写入溢出，区别是当时溢出发生在栈内存上，而此处溢出发生在堆内存上。这类错误会产生什么后果？我们来观察一下。
- 运行 `./buggy 1 leland` 程序可以正确运行，参数长度符合程序条件。现在尝试更长的参数 `./buggy 1 stanford` 和 `./buggy 1 lelandstanford`，但令人惊讶的是，这些参数似乎也“没问题”，显然在溢出相对较小的情况下，程序仍然可以幸运地执行。可以继续尝试更长的输入，似乎很难暴露溢出的问题。
- 许多程序错误并没有明确给出“segmentation fault”这样的提示，但这类错误通常也会破坏程序的状态，并且非常难以发现。此时就需要使用 Valgrind 来辅助我们。
- 尝试 `valgrind ./buggy 1 stanford` 并查看 Valgrind 的报告，看看它提供了哪些信息。无论写入超出 1 个字节还是 1000 个字节，Valgrind 都会在越界时提供错误报告。这是一个非常强大的工具！
- `error #2` 和 `error #3` 提供了其他滥用堆内存的问题。依次检查这些代码，确定问题的形式，然后运行（例如 `./buggy 2`）。是否可以观察到错误结果？在 Valgrind 下再次运行它。如果能把 Valgrind 报告中使用的术语关联到错误代码，后续遇到类似报告时，就可以很快定位问题所在。

需要警醒的是，**内存错误**（memory error）可能非常难以捉摸。当错误发生时，有些程序会立即崩溃，但有些程序隐藏较深，会悄悄破坏一些东西，直到运行很久以后才会暴露。所以，这类错误很难将观察到的情况与其根本原因联系起来。最令人沮丧的是那些“运气好”的错误，它们一般不会造成明显的破坏，但在某些特殊的情况下，往往会给你带来“惊喜”。**养成在开发过程中尽早并经常使用 Valgrind 的习惯，例行检测并消除内存错误！**

# 作业 3：有趣的堆

本次作业既用于测试你对话题 3 的理解，也是对话题 2 的进一步探索。在动态内存的基础上，继续深入研究数组和指针，并通过以下几个方面的训练，培养你的技能： 

- 操作指针和数组
- 管理栈和堆上的内存分配
- 使用 C 标准库中的 I/O 函数
- 使用 Valgrind 等工具辅助追踪内存错误和泄漏

为了帮助你评估学习进度，对于每个作业/实验，我们罗列了一些要点，并提供了一些思考问题。在完成作业后，可以使用这些问题进行自我检查。如果你不能很好地回答这些问题，那么还需要进一步努力。

- 作业 2 中编写的 `scan_token` 函数要求用户提供内存，用于存储扫描的词元。而作业 3 中的 `read_line` 函数却为用户分配好了内存。这两种方法有何优缺点？
- 据说，一个正确的程序，`malloc` 调用和 `free` 调用应该是一一对应的。如果添加了 `realloc` 调用，这将如何改变所需的 `malloc` 和 `free` 调用数量？
- 内存错误和内存泄漏哪个问题更严重，为什么？如何区分 Valgrind 报告了哪种错误？
- 对于运行时或内存分配的效率，如何衡量你的程序是否具有可接受的性能？
- 什么时候适合使用 `calloc` 代替 `malloc`？

## 初始项目

你的个人用户目录下应该已经有 `cs102` 这个文件夹了，通过下面的命令拷贝初始代码到该目录中：

```shell
cp -r /home/cs102-shared/assignments/assign3 ~/cs102
```

## 内存分配

本次作业提供了许多内存管理的针对性训练。编程过程中，你将出于各种目的使用栈和堆，并且需要注意适当地分配和正确地释放。以下是关于内存的一些通用指南以及针对程序的一些建议：

- 栈分配（stack allocation）就像声明变量一样简单。栈很方便（自动分配/释放）、具备类型安全并且非常高效。
- 动态分配是通过 `malloc/realloc/free` 进行的。利用堆内存，程序员能够控制生命周期（显式分配/释放）并提高程序的灵活性（可以调整存储大小/重新调整用途），但会牺牲安全性和效率。
- 注意理解栈分配与堆分配的正确使用以及两者适用的场景。根据一般的经验，除非必须使用动态分配的情况，首选栈分配。这两种技术通常会在程序中同时出现。在以下情况下，堆分配是必要的：
	- 需要一个非常大的内存分配，可能会耗尽栈空间
	- 需要控制内存的生命周期，或者内存必须在函数调用之外持续存在
	- 需要在初始分配后调整内存大小

始终使用 Valgrind 至关重要。查看 [Valgrind 指南](https://web.stanford.edu/class/archive/cs/cs107/cs107.1206/resources/valgrind.html)并回顾实验 2 和 3 中的练习，确保熟练使用 Valgrind。特别是：

- 内存错误。这是迄今为止让 Valgrind 辅助我们编程的最重要原因。如果 Valgrind 报告错误，则需要立即处理。
- 内存泄漏。如果 Valgrind 报告泄漏，则说明有一些堆内存分配后没有释放。内存泄漏通常不会立刻导致程序错误，但错误的释放反而可能会导致错误，因此我们建议在程序完成之前不要担心内存释放的问题。开发完成后，再单独处理内存释放，并确保每一步的正确性。

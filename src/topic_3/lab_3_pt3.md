# Valgrind 检测内存泄漏

虽然**内存泄漏**（memory leaks）不是内存错误，但 Valgrind 也可以帮助我们检测此类问题。内存泄漏是指在堆上分配内存但不释放它。这类问题很少会导致程序崩溃，所以我们建议你在程序编写完成之前，不要过早担心内存泄漏。等程序开发完成后，再安排时间专门处理内存释放的问题，但要确保每一次释放的正确性。然而，内存泄漏仍然是一个程序设计上的错误，因为你的程序有责任清理不再需要的任何内存。特别是较大的程序，如果你分配非常大的内存但却从不释放，那么很可能会耗尽堆中的内存！

程序 `leaks.c` 植入了一些内存泄漏的代码，练习并了解 Valgrind 如何处理并报告内存泄漏问题。

- 查看 `leaks.c` 中的程序并考虑 `leak #1`。当执行 `./leaks 1` 时，程序将在堆上分配 8 个字节，但随后立即返回，导致程序丢失该堆内存的地址。此时发生了内存泄漏，但程序却正常终止了。让我们看看 Valgrind 如何帮助我们检测这个问题。
- 尝试 `valgrind ./leaks 1` 并查看 Valgrind 报告，看看提供了哪些帮助信息。你会注意到 Valgrind 输出的底部报告了 “LEAK SUMMARY” 以及整个堆的使用情况的摘要，其中显示了退出时仍在使用的内存（退出应该释放）。你还可以看到报告的分配和释放的数量不匹配，这也表明存在泄漏。非常有帮助！
- 有关内存泄漏更多信息，请确保在运行 Valgrind 时使用 `--leak-check=full` 和 `--show-leak-kinds=all` 参数标志。像这样再次运行 `valgrind --leak-check=full --show-leak-kinds=all ./leaks 1` 将显示更多信息，包含泄漏的内存在代码中最初分配的位置！我们建议始终使用这些参数标志运行 Valgrind 以便获得最多信息。请确保将这些标志放在运行实际程序的命令之前。具体来说，以下内容并不等效：`valgrind ./leaks 1 --leak-check=full --show-leak-kinds=all`，因为这会将这些标志传递给你的程序，而不是 Valgrind 本身！
- 报告中的“definitely lost”、“indirectly lost”等有什么区别？了解更多信息可以查看 [Valgrind guide](https://web.stanford.edu/class/archive/cs/cs107/cs107.1206/resources/valgrind.html) 在线文档。
- `leak #2` 和 `leak #3` 提供了其他内存泄漏的可能表现形式。依次检查这些代码，确定问题的形式，然后运行（例如 `./leaks 2`）。可以看出程序每次运行都很良好。现在在 Valgrind 下运行它。请注意 Valgrind 报告使用的术语以及它与根本原因之间的关系。请注意，泄漏不仅是使用 `malloc` 分配的内存。像 `strdup` 这样的函数也会分配内存，由调用者负责释放！
- 整个堆的使用量不仅仅包括显式分配，其他函数（例如 `strdup`）也可以在内部分配/释放内存！

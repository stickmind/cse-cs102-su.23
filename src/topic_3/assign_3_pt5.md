# 测试与提交

本次作业也会查看你的程序的内存和运行时效率。对于内存效率，Valgrind 可以提供巨大的帮助，因为 Valgrind 报告包含有关总堆使用情况的统计信息。在 Valgrind 报告末尾查找以下格式的行：

```
total heap usage: 10 allocs, 10 frees, 888 bytes allocated
```

这是程序生命周期内所有堆分配的总和。分配计数应始终等于释放计数。分配计数和分配的总大小是程序内存“占用空间”的衡量标准。

运行时效率（程序运行的速度）也很重要。在命令前面加上执行时间并报告完成该命令所用的时间。例如，` time ./mytail` 将测量程序的运行时间，而 `time samples/mytail_soln` 将测量示例程序的运行时间。标记为“用户”的时间是我们感兴趣的部分。

```Shell
$ time ./mytail -1 samples/dictionary
zygote

real    0m0.010s
user    0m0.006s
sys     0m0.000s
```

```Shell
$ time samples/mytail_soln -1 samples/dictionary
zygote

real    0m0.009s
user    0m0.007s
sys     0m0.000s
```

那么如何确保分配适当的内存，以及合理的运行时效率呢？最佳策略是使用给定输入测量示例程序，并用相同输入测量你的程序。如果你的程序和示例程序的结果大致相同（例如在 2 或 3 倍之内），那么你的实现就没什么大问题。当考虑空间与时间的权衡时，示例程序向你展示了我们正在寻找的平衡点。如果你的程序使用明显更多的内存或时间，则表明你的程序有一些不必要或多余的工作应该消除。请务必注意，非常小的输入对于有意义的测量来说太小；相反，你应该测量较大的输入，以查看程序的大规模运行情况。

作为作业的一部分，你应该尽可能完善 `custom_tests` 中的测试案例，至少添加 3 到 5 个。为了更好的可读性，也建议你为代码和测试用例编写注释或文档。这些注释用于说明每个测试的初衷，以及这些测试之间的相互关系。

遵循实验 3 中介绍的调试策略，一个关键原则是**不要随意更改代码**：

- **观察漏洞行为**。
- **创建一个可复现输入**。
- **缩小检查范围**。
- **分析**。
- **设计实验并验证**。
- **修改代码消除错误**。

作业提交方式参考作业 0，可以使用 `submit` 提交你的代码。为了追求完美，一些加分项值得你去注意：

- 编译是否干净，有无警告等编译错误？
- 默认测试是否全部通过？
- 自定义测试案例是否全面？

对于代码实现部分：

- 有没有其他地方，还可以使用位运算进行改写？
- 算法是否高效？还记得如何分析算法复杂度吗？
- 代码风格及可读性是否注意过？有没有进行函数拆分，提取出一些更通用的代码？
- 有没有尝试编写文档？一份好的代码就如同一篇优美的散文，不多一字，也不少一字。加油！


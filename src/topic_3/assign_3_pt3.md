# 实现 mytail


> **注意** 如何对管道中运行的程序使用 `gdb/valgrind`？
> 
> GDB 和 Valgrind 不能很好地与管道配合使用。一种简单的替代方法是，为待测试的输入编写一个文件，然后在该文件上运行 `gdb/valgrind` 程序。提供输入时，你可以使用重定向 `>` 来捕获命令的输出。

标准 `tail` 命令是一个过滤器命令，读取输入，并按顺序打印输入的最后 `N` 行。 `N` 的值默认为 `10`，但也可以设置为命令行标志，例如 `tail -4`。以下是 `tail` 的使用示例：

```Shell
$ cat samples/colors
red
green
green
yellow
blue
blue
blue
blue
$ tail -3 samples/colors 
blue
blue
blue
```

如果输入包含的总行数少于 `N`，则打印输入中的所有行。

你要编写的 `mytail` 程序在操作上与标准 `tail` 类似，但存在以下差异：

- `mytail` 仅支持一个命令行标志 `-N`，其中 `N` 是要输出的行数（标准 `tail` 有许多其他标志）
- `mytail` 只读取一个文件：指定文件（如果指定）或标准输入（如果没有）（标准 `tail` 可以从任意数量的文件参数读取）

当 `mytail` 处理其输入时，它需要跟踪 `N` 个行。为此，你必须使用包含 `N` 个条目的数组。在任何时候，该数组都保存最近读取的 `N` 行。该数组是一个由 `N` 行组成的“滑动窗口”（slide window），它在输入过程中移动。当 `mytail` 到达输入末尾时，该窗口仅包含最后 `N` 行。

当 `mytail` 开始处理输入时，它将使用 `read_line` 函数将前 `N` 行读入数组。读取第 `N+1` 行时，不应扩大数组，而应丢弃输入的第一行（最初的行）并将该数组位置用于存储第 `N+1` 行。 `N+2` 行覆盖最初的第二行，依此类推。这样，数组就相当于一种循环队列，在任何时候最多存储最近读取的 `N` 行。

由于数组大小是预先已知的并且在其生命周期内不会改变，因此该数组是使用栈分配的好机会。实现该程序的挑战是理解循环队列的逻辑以及要小心分配和释放字符串。

重要提示：确保理解 Slide Window 方法，并按该方法实现你的 `mytail` 程序！有些地方也将该数组称作“环形缓冲区”。

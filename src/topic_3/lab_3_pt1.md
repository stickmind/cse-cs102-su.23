# 堆内存的使用

在 `heap.c` 文件中包含了一些使用 `malloc`、`strdup` 和 `realloc` 在堆上动态分配内存的代码。你可以在 `gdb` 中运行或跟踪该文件，其中有两个示例函数，`remove_first_occurrence` 和 `join`。

函数 `remove_first_occurrence(text, pattern)` 返回一个字符串，该字符串是 `text` 的副本，删除了首次出现的 `pattern`。返回的字符串是在堆上分配的，完成后将由客户端负责释放。以下列出了一些问题供你思考，以便理解这个函数的实现代码：

- 库函数 `strstr` 的用途是什么？它返回什么？
- 第 17~19 行用于处理 `text` 中没有出现 `pattern` 的情况，即没有要删除的内容。为什么该函数返回 `strdup(text)` 而不直接返回 `text`？
- 第 21 行两个指针相减，其结果是什么？提示：如果 `q = p + 3`，则 `q - p` 结果为 3。此处 `sizeof(pointee)` 如何影响减法的结果？
- 如果传入的表达式为 `false`，那么 `assert` 将终止程序。第 24 行的作用是什么？
- 第 26 行执行后，字符串 `result` 是否以空字符结尾？为什么？
- 你的同事建议将第 27 行更改为 `strcat(result, found + nremoved)` 并声称其操作是等效的。你尝试了一下，似乎确实是等效的。真的是这样吗？不，不完全是……这行代码只是“运气好”而已。它以什么样的方式错误地依赖于初始内容（堆内存上分配）？当该假设不成立时，函数将如何崩溃？
- 尝试运行代码。如果不带参数运行 `./heap`，它将运行一个简短的测试，从“centimeter”中删除“time”。

函数 `join(strings, strings_count)` 返回一个字符串，该字符串由 `strings` 中前 `strings_count` 个字符串串联拼接而成。返回的字符串是在堆上分配的，完成后由客户端负责释放。该实现的核心函数是 `realloc` 函数。以下列出了一些问题供你思考，以便理解这个函数的实现代码：

- 在循环开始时，所需的堆内存总大小是未知的，因此无法预先进行分配。相反，它会先分配一个初始内存，然后在每次附加字符串时扩大该内存。这种按需调整内存的方式是 `realloc` 的惯用法。
- 提供给 `realloc` 的分配大小参数，是额外增加的字节数呢，还是包括现有内存在内的总字节数？
- 变量 `result` 被初始化为 `strdup(strings[0])`。为什么要拷贝字符串而不是直接赋值 `result = strings[0]` ？
- `man realloc` 手册介绍说 `realloc(ptr, newsize)` 的返回值可能与 `ptr` 相同，但也可能不同。如果不同，`realloc` 会将旧位置的内容复制到新位置，然后释放旧位置的内存。更改代码，在调用 `realloc` 后不使用其返回值（即，不重新赋值给 `result`，直接丢弃返回结果）。重新编译程序，你应该会收到编译器的警告。该警告试图让你注意什么错误？不捕获返回值的 `realloc` 调用永远不正确的！
- 尝试运行代码。如果使用一个或多个参数运行 `./heap`，它将使用 `join` 函数将所有参数连接在一起。

最后，我们将研究 `calloc` 的实现（`malloc` 内存分配函数的替代函数），以便更好地理解堆内存分配的工作原理。首先，阅读该函数的文档 `man calloc`，然后查看 `musl_calloc` 实现（基于 `musl` 的代码）。

`calloc` 接口包含用于确定分配数组元素个数的 `nelems` 以及元素类型大小的 `elemsz`。该接口会将内存内容初始化为零，这是 `calloc` 区别于 `malloc` 的特点。以下列出了一些问题供你思考，以便理解这个函数的实现代码：

- 用数组描述的 `calloc` 接口可能有些误导，因为其操作没有任何特定于数组的内容。它只是分配一个总大小为 `nelems * elemsz` 字节的区域。调用 `calloc(10, 2)` 或 `calloc(4, 5)` 或 `calloc(1, 20)` 效果完全相同，分配的内存都可以用来存储长度为 20 的字符串或长度为 5 的整型数组。
- 该函数的第 44~46 行在做什么？如果删除这些代码对函数的运行会产生什么影响？
- 你的一位同事反对在第 44 行使用除法，因为除法比乘法更耗时，并且需要额外检查零除数。他们建议将其更改为 `if (nelems * elemsz > SIZE_MAX)`，认为这是等效的并且运行更高效。请你向他们解释为什么这个方案行不通。
- 第 48 行将 `p` 声明为 `void*` 类型，它与 `malloc` 的返回类型匹配。 `void*` 是泛型指针，它存储一个地址，但不声明数据的类型。对 `void*` 解引用或进行指针算术运算是非法的，因为这两个操作都取决于数据的类型，但在本例中指针的类型是未知的。然而，`void*` 可以省略显式强制转换直接赋值。
- 第 49 行的目的是什么？如果删除该测试并且它始终进入循环，会对函数的操作产生什么影响？
- 第 51 行包含表达式 `sizeof(*wp)`。鉴于 `wp` 已声明但未进行分配，这看起来会解引用一个未初始化的指针！但此处不用担心，事实证明 `sizeof` 是在编译时根据其声明类型来计算表达式大小的。由于 `wp` 被声明为 `long*`，因此表达式 `*wp` 的类型为 `long`，在服务器上其大小为 8 个字节。编译器会将其转换为 `(total + 8 - 1)/8`。
- 进一步深入研究第 51 行，这行代码应该会让你想起实验 1 中的 `roundup` 函数。对于 `calloc(20, 4)`、`calloc(2, 7)` 或 `calloc(3, 1)` 这些调用，`nw` 的值是多少？正如你的推测，这是一个舍入操作。对于给定的请求 `malloc` 实际上分配了多少个字节，该表达式做出了一个假设。请问这个假设是什么？
  注意，这个行为不是该接口默认提供的，在使用过程中我们不应该假设这一点。由于 `calloc` 和 `malloc` 是由同一个程序员编写的，其对 `malloc` 内部结构了如指掌，因此 `calloc` 的实现作了这样的假设。
- 第 52 行 `for` 循环的初始化部分，赋值语句 `wp = p` 中的 `wp` 和 `p` 的声明类型不同，这里为什么不需要类型转换？如果添加类型转换 `wp = (long *)p`，该函数的行为是否会有所不同？
- 第 52 行 `for` 循环的增量部分使用了 C 语言的逗号运算符，难得一见！可以在[维基百科](https://en.wikipedia.org/wiki/Comma_operator)上阅读有关逗号运算符的更多信息；在实际代码中你可能看到该运算符的唯一用途是将多个表达式打包到循环的初始化或增量部分中。在本例中，增量部分将同时使指针 `wp` 前进并减少迭代的计数  `nw`。
- 想象一下，如果第 50 行的声明改为 `char* wp`，代码其他部分不进行更改，这将如何改变该函数的行为？如果声明是 `int* wp` 情况又会如何？如果声明是 `void* wp` 呢？对于每种情况，考虑指针类型如何影响 `wp++` 和 `*wp = 0` 的操作。你认为作者选择 `long*` 的动机是什么？

# 背景：过滤命令

`uniq` 和 `tail` 是一类特殊的命令，称为“过滤器”。过滤器是这样一种程序，它从用户或文件中读取输入（通常是逐行读入），以某种方式转换输入，并生成一些输出。其他一些过滤器命令还有 `cat`、`sort` 和 `grep` 等。

`cat` 是所有过滤器中最简单的，直接将输入进行输出。调用 `cat filename` 将打印指定文件的内容。 文档 `man cat` 表明，如果没有给出文件名参数，该命令将从**标准输入**读取。这意味着程序将读取用户在终端上键入的行。几乎每个过滤器（例如 `grep` `wc` `less` `head` `sort` 等）都遵循相同的接口，要么从指定的文件读取，要么从标准输入读取。从标准输入读取可以方便地进行快速测试，无需提前创建文件。

自己尝试一下：

- 调用 `cat Makefile` 来查看文件的内容。
- 使用 `-b` 参数可以对非空白行进行编号：`cat -b Makefile`。
- 现在调用不带文件名参数的 `cat -b`，此时程序将等待你键入输入。
- 输入一行文本并按 Enter 键，观察该行及其行号的对应关系。再输入几行，也会进行输出并编号。
- 完成输入后，在单独的一行上按 `Control-d`，这表示输入结束（`EOF` 表示“文件结束”），过滤程序将退出。

下面是一些其他可供探索的过滤器。对于每个命令，请浏览 `man` 文档以了解其选项。在现有文件上运行过滤器，然后在没有文件名的情况下再次运行过滤器并通过标准输入进行操作。请记住，`Control-d` 用于发出 `EOF` 信号。

- `head` 打印输入的前几行  
- `tail` 打印输入的后几行  
- `wc` 打印输入中的行数、单词数和字符数  
- `grep` 从输入中打印与搜索模式匹配的行  
- `uniq` 从输入中过滤掉相邻的重复行  
- `sort` 按顺序重新排列输入并打印

在标准输入上运行时，你会注意到某些过滤器会立即响应输入的每一行，例如如果与模式匹配，`grep` 会立刻回显该行。其他的命令，例如 `sort`，在你发出 `EOF` 信号之前不会输出任何内容。这取决于过滤器操作是否需要查看所有输入才能确定输出内容。

过滤器的真正威力在于它们可以组合成“管道”。管道是一系列命令，其中一个命令的输出被传递到（或“通过管道传输到”）下一个命令的输入。管道字符 `|` 将一个命令的输出作为下一个命令的输入。过滤器在管道中特别有用，因为它们可以在开始、中间或末尾使用。

管道允许你通过组合基本的过滤器，构建出更强大的操作。以下是一些例子：

- `grep include util.c | wc -l` 在 `util.c` 中查找包含“include”的行，并将它们提供给 `wc`，`wc` 输出其接收到的输入中的行数。因此，该管道将输出匹配的行数。
- `cat -b util.c | tail` 输出 `util.c` 中标有行号的行，并将它们提供给 `tail`，后者仅输出最后 10 行和行号。
- 标准 `uniq` 命令仅过滤掉输入中相邻的重复行，而你的版本将过滤掉输入中任何位置出现的重复行。因此，使用标准 `uniq` 命令时，如果你的数据中有分散的重复行，则需要先重新排序，以便让重复项保持相邻位置，然后 `uniq` 才会检测到它们。我们可以使用三阶管道来输出文件中不同行的计数：`sort samples/names | uniq | wc -l`。首先，`sort` 将 `samples/names` 排序并输出给 `uniq`，`uniq` 忽略相邻的重复项输出到 `wc`，最后 `wc` 统计接收到的输入的行数并打印。
- 现在轮到你了！如何编写一个管道来打印 `samples/names` 中三个最常见的名称？

Unix/Linux 的哲学是放弃构建单一的万能程序，而是鼓励创建更小的命令。每个命令都只负责某个单一任务，并足够精简。这些小的、离散的工具，通过管道进行组合，从而完成更大的任务。在本次作业中，你将编写其中的两个工具：`uniq` 和 `tail`。

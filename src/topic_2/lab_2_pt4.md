# 探究 strtok

一种常见的字符串处理模式是将字符串拆分为“词元”或“token”。这些词元是由一个或多个分隔字符分隔出来的，例如将句子按空格拆分为单词或将文件路径按斜杠拆分为独立的组件。

C 标准库提供了一个 `strtok` 函数，但其​​笨拙的设计使得该函数的使用变得较为混乱且容易出错。我们将研究这个函数及其存在的问题，以此作为一个警示。在作业 2 中，你将编写一个改进的 `tokenize` 函数，在编写过程中要注意避免此类错误！

我们首先以用户身份来使用 `strtok` 函数。可以通过 `man strtok` 熟悉其操作，注意 BUGS 部分中对该函数设计的批评。

与 C++ 等其他语言中类似的函数不同，只调用一次 `strtok` 并不会返回一个格式化好的类似 `vector` 一样的词元容器。相反，你必须重复调用 `strtok`，每次只能返回一个词元。直到 `strtok` 返回 `NULL` 时，才表示没有多余的词元。以下是一个常见的编程习语：

```c
char* token = strtok(input, delims);
while (token != NULL) {
    printf("%s\n", token);
    token = strtok(NULL, delims);
}
```

关于 `strtok` 的诟病主要体现在两个方面，其一是它破坏性地修改了输入，其二是它一次只能处理一个词元。下面我们分别探讨下这些问题：

**设计问题  1：`strtok` 修改了传入的参数**。 `strtok` 没有为每个词元创建一个新的子字符串，而是使用空字符 `NUL` 覆盖原字符串中的分割符，并返回指向首个词元的指针。该函数有效地将输入字符串分割成一系列词元，某种程度上，它重新利用了现有字符串，避免将字符复制到其他位置。例如字符串 `red-green-blue\0`，重复调用 `strtok` 以 `-` 进行分割后，该字符串将变为 `red\0green\0blue\0`。

**设计问题 2：`strtok` 不允许常量输入**。该函数不仅破坏了输入参数，而且这种设计还无法处理字符串常量（只读）。程序 `token.c` 有一个示例，它将字符串常量作为输入传递给 `strtok`。取消该部分的代码注释，尝试编译并运行程序，看看 `strtok` 在处理字符串常量时的报错信息。

**设计问题 3：`strtok` 一次只能处理一个词元**。在第一次调用 `strtok` 时，第一个参数是待处理的字符串。但在后续调用中，第一个参数将变为 `NULL`，这是告诉 `strtok` 要从上一次调用的中断处，继续处理同一个字符串。在内部实现中，`strtok` 使用了一个全局变量来保存第一次调用时的原始输入字符串，并在后续调用中更新该变量。天哪！此行为与典型的函数调用形成了鲜明对比，典型的函数调用应该完全独立，不应该与任何先前或将来的调用相关联。这不仅让调试变得更困难，而且一次最多只能处理一个词元。该函数有一个状态变量，可以供所有调用共享。每次调用，函数都会将状态保存至该变量，再次调用函数时，会用新的值覆盖该变量。

在 `token.c` 中包含了一份 `strtok` 的实现，该实现改编自 [musl](https://musl.libc.org/) 库。有很多谜题需要我们逐一揭开！绘制内存图并跟踪 `s` 和 `p` 在调用期间的变化，或者在 `gdb` 下运行该程序可能会有所帮助。

- 第 12 行：关于[静态变量](https://en.wikipedia.org/wiki/Static_variable)的维基百科页面提供了一些背景信息和静态局部变量的示例。 `static` 有什么作用？为什么要在这里使用它？
  请注意，静态变量的初始化方式与非静态局部变量不同。尽管该函数看起来每次调用时都会声明一个新变量 `p` 并初始化，但**静态变量只能被声明和初始化一次**。在多次调用之间，`p` 的值将会保留，不会收回。
- 第 14~19 行：当 `NULL` 作为第一个参数传递时，`s` 如何获取值？
- 第 21 和 27 行：函数 `strspn` 和 `strcspn` 有何作用？
- 第 21 行：在这一行的执行过程中 `s` 是如何更新的？
- 第 22 行：表达式 `*s` 的计算结果是什么？这个表达式的另一种替代写法是什么？ （为了可读性，这种替代写法或许更好，但是唉……）
- 第 24 行：什么情况下函数会通过第 24 行退出？
- 第 27 行：执行完这一行后，`p` 指向哪里？
- 第 29 行：搞清楚这行代码的赋值操作，看它是如何改变输入参数的。该行执行结束后，`p` 指向哪里？
- 第 29 和 32 行：这两行似乎有些相似，都将 `0` 赋值给 `p`，但它们的目的却存在着重大差异。`p = NULL`，`*p = '\0' `与 `p = ""` 这些表达式有什么区别？


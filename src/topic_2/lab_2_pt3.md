# 使用 Valgrind

每个实验室都会花一些时间来练习工具的使用。上周，是 `sanitycheck` 和 `gdb`。本周，我们介绍 Valgrind。

从现在开始，我们将大量使用指针，我们的程序出现内存错误的风险也将变得更大。这些错误很难追踪，此时学习 Valgrind 工具将很有必要。 Valgrind 是一个帮助检测内存错误的工具。[Valgrind Memcheck](https://web.stanford.edu/class/archive/cs/cs107/cs107.1206/resources/valgrind) 是关于 Valgrind 的一份很好的指南。

下面让我们尝试使用 Valgrind 来修复程序。

- 阅读 `buggy.c` 中的代码，查看两个植入的内存错误。我们从错误 1 开始。
- 运行 `./buggy 1`，你应该可以看到 **Segmentation fault (core dumped)**。段错误是由于尝试读/写无法访问/无效的地址而导致的。好了，现在你知道程序中有个内存错误。
- 在 `gdb` 下再次运行该程序，你应该观察到相同的段错误。此时，尝试使用 `backtrace` 命令来定位程序崩溃时执行的位置。这个信息非常有用，但我们还需要更多！
- 退出 `gdb` 并在 Valgrind 下运行程序：`valgrind ./buggy 1`. Valgrind 的报告提供了更多详细的信息，包括内存错误的类型、执行的调用栈以及无效地址的值。此外，Valgrind 还检测到了段错误之前的一个问题——**Use of uninitialised value of size 8** 发生在 **Invalid read of size 1** 之前，前者是指针的大小，后者是 `char` 类型的大小。这个重要的信息可以引导你找到错误的根源！
- 重复上述过程，尝试解决错误 2 中的错误。错误 1 中的问题可能比较明显，但错误 2 中的问题仅凭肉眼很难发现——Valgrind 将非常有用！

针对程序中的错误，Valgrind 使用的术语和报告可能很难理解。这需要一些练习来熟悉，你练习的目标应该是将 Valgrind 报告的错误与代码中的位置和根源联系起来。

我们选择这些特殊案例来进一步证明内存错误的棘手性。这两个错误都来自某种形式的内存错误，但观察到的后果却不同。 错误 1 每次都会因段错误而崩溃，而错误 2 的输出有时正确有时不正确，但它不会崩溃。

内存错误可能不会造成明显的损害，但这并不意味着程序是正确的，它只是这次“幸运”而已。使用 Valgrind 可以检测到这些潜在的错误，避免后续产生不可挽回的损失。

检查完这些错误后，请回答以下问题：处理字符串时，什么错误可能是 Valgrind 报告的“**Conditional jump or move depends on uninitialised value(s)**”的根本原因？这是你在作业 2 中可能会犯的错误，因此现在了解其原因很有必要！

> **启示** 进行 Valgrind 例行检查
>
> 鉴于此，我们建议你在编写作业代码时，应该尽早并经常运行 Valgrind。每当 Valgrind 报告任何内存错误时，你就应该停下来并尝试解决它，然后再继续完成作业。让 Valgrind 的例行检查成为你的工作流的一部分，尤其是遇到错误时！

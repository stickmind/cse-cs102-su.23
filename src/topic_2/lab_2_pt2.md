# 探究 atoi

在作业 0 中，我们使用 `atoi` 函数将字符串参数转换为整数，该函数名来自 **ascii to integer** 的首字母。正如你在作业 0 中了解到的那样，`atoi` 使用起来非常方便，但却容易出错。在实际项目中，基本都被 `strtol` 函数取代了。本次作业就会迁移到这个新函数。函数 `strtol` 提供了更多的功能，但使用起来也更复杂。

在 `atoi.c` 程序中包含了一份 `atoi` 的实现，该实现改编自 [musl](https://musl.libc.org/) 库。你可以先编译并运行它。请注意，该程序的代码风格并不全都值得你效仿——我们的目的仅仅是通过此份代码理解该函数底层的实现逻辑。

以下列出的一些问题，用于引导你阅读 `musl_atoi` 的代码：

- 第 13 行：表达式 `*s` 计算后的值是什么？该表达式的另一种替代写法是什么？（或许替代的写法可读性更好……）
- 第 14 行：表达式 `s++` 对 `s` 做了什么？
- 第 17~23 行：如果字符串以减号 `-` 字符开头，那么哪行代码会让 `s` 跳过该字符？这很微妙！（`switch` 语句的 `fallthrough` 行为可能会令人非常惊讶，并且通常是由异常触发的，所以对于故意不写 `break` 语句的地方，最好能写清楚注释，但是……）
- 该代码有两处针对字符串的循环遍历，但却都没有使用 `NUL` 终止字符进行显式测试。为什么这样的测试是没必要的？
- 如何将单个数字字符转换为对应的数值？该值又如何与目前为止所构建的值进行结合？
- 第 28 行：关于 `s++` 的一个奇怪现象是，该表达式不仅修改 `s`，还会计算出 `s` 的原始值。关于该行为，推荐阅读 [Stack Overflow](https://stackoverflow.com/questions/7031326/what-is-the-difference-between-prefix-and-postfix-operators) 上的问题。换句话说，`s++` 会将 `s` 进行自增操作，但表达式的值不是自增后的值，而是原来的值。代码是如何利用该特性让字符串处理更简洁的？
- 第 25~31 行：该循环先将 `number` 建立为负值，然后再将其取负。注释表明这个决定可以避免在 `INT_MIN` 处发生溢出。为什么有必要将 `INT_MIN` 作为特殊情况？为什么程序将 `number` 构造为负数而不是正数？
- 当输入字符串包含非数字字符时会发生什么？如果该非数字字符是第一个字符又将如何？
- 第 31 行：三元表达式使用“`CONDITION ? IF_TRUE : IF_FALSE`”的形式进行计算。尝试解释 `return` 语句。

接下来编译 `atoi` 程序并做一些测试。选择一些感兴趣的输入，首先手动跟踪函数将如何处理，然后在 `gdb` 中逐步执行程序来验证你的理解是否正确。尝试一些可以成功转换的输入，例如 `./atoi 107 0 -12`，然​​后再尝试一些有问题或格式错误的输入，例如 `./atoi 3.14 binky @55 --8`。如果输入超出整数可以表示的范围，结果将会如何？溢出？饱和？返回 0？引发错误？还是完全执行其他操作？

# 实现 mywhich

前两个任务通过测试和调试，完善了你的工具函数。现在可以利用它们，构建一个更大的程序：实现一个你自己的 `which` 命令，该命令用于定位和识别要运行的可执行程序。

文件 `mywhich.c` 提供了一个不完整的主函数，该函数实现了一个不带参数调用 `mywhich` 时的行为。你应该首先阅读并理解这部分代码，弄清楚如何更改或扩展它，以满足你自己的需求，最后为你的实现策略添加适当的注释。我们也鼓励你对现有的代码进行修改、分解，以便实现尽可能干净且设计良好的代码。

阅读代码时可以考虑以下一些关键点：

- `PATH_MAX` 是什么？它有什么作用？
- 当应用在数组上时，运算符 `sizeof` 可以方便地返回数组的实际大小。然而，一旦作为参数传递，该数组将退化为指向第一个元素的指针，`sizeof` 将返回 8 个字节而不是数组实际大小，因为指针总是 8 个字节。另外注意，如果是字符串，则数组大小不一定与字符串长度相同。
- 如果用户的环境不包含 `MYPATH` 值，那么 `mywhich` 将使用什么值来代替？
- 参阅 `tokenize.c` 和 `mywhich.c` 中的示例，客户端如何正确使用 `scan_token`？

作业代码已经删除了注释，你的工作就是完善缺失的文档。对于 `tokenize.c` 或 `myprintenv.c` 程序，根据个人精力，不强求注释。

你要编写的 `mywhich` 程序在行为上和标准 `which` 命令类似，但有以下一些差异：

- `mywhich` 使用环境变量 `MYPATH` 作为搜索路径。如果不存在这样的环境变量，则会回退到 `PATH`。（标准 `which` 始终使用 `PATH` 作为搜索路径）
- `mywhich` 不支持任何命令行参数。（标准 `which -a` 可以打印所有匹配项）
- 不带参数调用 `mywhich` 会打印搜索路径中的目录，一行一个目录。这样的设计目的是提供一个测试工具，用于验证你的工具函数是否正常工作。（标准 `which` 没有参数时什么也不做）
  
	```Shell
	$ ./mywhich
	Directories in search path:
	/usr/local/sbin
	/usr/local/bin
	/usr/sbin
	/usr/bin
	/sbin
	/bin
	/usr/games
	/usr/local/games
	/snap/bin
	/usr/local/ssl/bin  
	```
- 使用一个或多个参数调用 `mywhich` 会分别为每个参数执行搜索任务。下面的示例演示调用 `mywhich` 来查找三个可执行程序。对于每个可执行程序，它会打印首个匹配到的完整路径，如果找不到路径，则不打印任何内容。每个程序的路径会按照命令行提供的顺序进行打印。在这个示例中，找到了其中的两个，但在用户 `MYPATH` 的所有目录中均未找到名为 `xemacs` 的可执行程序，因此未打印任何内容。
  
  ```Shell
  $ ./mywhich xemacs submit cp
  /usr/local/bin/submit
  /usr/bin/cp
  ```

命令将仅包含非特殊字符，即没有 `^ # * / $ %` 字符，这些在 Unix/Linux 中具有特殊含义。

你应该使用不同的搜索路径配置进行测试。我们建议你只更改 `MYPATH`，而不是永久更改你的实际 `PATH`，这可能会影响系统正常工作。修改后 `MYPATH` 只会影响 `mywhich` 的行为，对系统其它组件不会产生任何影响。使用之前提到的 `env` 命令在运行 `mywhich` 时设置 `MYPATH` 的值，如下所示：

```Shell
$ env MYPATH=/tmp:samples ./mywhich mywhich_soln
samples/mywhich_soln
```

此外也建议使用 `sanitycheck` 和示例程序进行测试。例如，对于 `./mywhich` 的任何命令参数，请尝试使用 `samples/mywhich_soln` 进行相同的调用，以验证你的程序和示例具有相同的行为。

**可以作如下假设**：假设用户能够正确使用 `mywhich`，并且用户的 `MYPATH` 和 `PATH` 变量正确设置，即由冒号分隔的格式化路径序列。不需要测试 `-a` 等命令参数，并且程序名没有特殊字符。

**补充**：用户的 `MYPATH` 定义搜索路径，如果用户环境中没有 `MYPATH` 变量，则为 `PATH`。命令 `mywhich` 按照路径中列出的目录顺序进行搜索。如果目录包含一个**可读的**可执行程序文件，其名称与命令完全匹配，则搜索将停止并打印该程序文件的完整路径。

那么如何测试一个文件是否是可执行文件呢？你必须使用库函数 `access()` ([`man access`](https://www.man7.org/linux/man-pages/man2/access.2.html))。给定完整路径和“模式”，该函数会判断是否可以按指定模式访问该路径。模式可以是 `R_OK` 和 `X_OK` 的组合。这将验证你是否有权读取该文件，并判断该文件是否可执行。请务必仔细阅读标准库手册，了解如何正确使用该函数。

“模式”作为位掩码提供。例如，如果你想要 `R_OK` 和 `X_OK` 两个模式，则必须提供一个同时打开这两个位的掩码。

另一个小细节是，目录的权限是可读的，也是可执行的，因此对于 `mywhich` 来说，目录似乎也可能是可执行文件。可以使用 [`man stat`](https://www.man7.org/linux/man-pages/man2/stat.2.html) 进一步了解文件系统来区分目录和文件，但作业不需要编写代码进行这样的检测。`mywhich` 应该只通过 `access` 过滤结果，找出可读/可执行的匹配条目即可，不需要关心这些结果是文件还是目录。这也是示例程序表现出的行为。

# GDB 探究指针和数组

首先，我们将研究指针和数组语法以及两者之间的异同。为此，我们将使用 `code.c` 程序，这个示例程序展示了数组和指针的各种行为。

构建程序，在 `gdb` 下启动它，并在 `main` 处设置断点。当程序在断点处停止时，使用 `info locals` 查看未初始化的栈变量状态。该命令列出当前函数中所有局部变量的值。单步执行初始化语句并再次使用 `info locals`。注意，当 `gdb` 报告执行在第 N 行时，第 N 行尚未执行。

下面表达式都引用了局部变量 `arr`。对于每个表达式，先尝试弄清楚该表达式的结果是什么，然后在 `gdb` 中验证你的理解是否正确。

```c
(gdb) p *arr
(gdb) p arr[1]
(gdb) p &arr[1]
(gdb) p *(arr + 2)
(gdb) p &arr[3] - &arr[1]

(gdb) p sizeof(arr)
(gdb) p arr = arr + 1
```

函数 `main` 将 `ptr` 初始化为 `arr`。栈上的数组名和指向该数组的指针几乎可以互换，但又不完全可以互换。尝试用 `ptr` 替换 `arr` 重新计算上述表达式。前五个表达式的计算结果相同，但后两个表达式的结果却不同。数组大小是多少？指针的大小又是多少？最后一个表达式是最难理解的。为什么可以给 `ptr` 赋值，但不能给 `arr` 赋值？

执行 `p ptr = ptr - 1` 将 `ptr` 重置为其原始值。使用 `step` 命令进入 `binky(arr, ptr)` 调用栈。 `step` 与 `next` 类似，但它不是执行整行并移至下一行，而是进入当前执行的行。进入 `binky` 后，使用 `info args` 查看两个参数的值。利用变量 `a` 和 `b`，打印你能想到的任何表达式，它们将得出相同的结果。对于上面最后两个表达式：`sizeof` 报告 `a` 和 `b` 的大小相同，并且两者都允许赋值。参数传递过程中发生了什么情况才能实现这一点？尝试画出内存示意图来阐明这个问题。

在 `change_char` 上设置断点并使用命令 `continue` 继续执行。当 `gdb` 在断点处停止时，使用 `info args` 可以查看当前函数栈 `change_char` 的参数。

使用 `backtrace` 可以查看当前位置的函数调用栈帧列表。使用 `frame` 命令可以选择不同的栈帧。在 `backtrace` 命令的输出中，函数栈帧由内到外从 0 开始编号。尝试使用命令 `frame 1` 来选择 `change_char` 的上一层栈帧，然后使用 `info locals` 来查看 `winky` 的状态。也可以使用简写命令，`up` 可以进入上一层栈帧，`down` 可以进入下一层栈帧。最后，执行 `frame 0` 返回到调试器停止的位置。

单步执行 `change_char` 并检查每行之前和之后的状态。使用 `info args` 查看当前栈帧的参数，然后使用 `up` 和 `info locals` 查看上一层栈帧中变量发生的变化。仔细观察每条赋值语句的效果。

单步执行 `change_ptr` 并进行相同的观察。哪些赋值语句对 `winky` 具有持久效果，哪些没有？你能解释为什么吗？

